{
  "root": {
    "id": "root",
    "name": "root",
    "displayName": "Root",
    "type": "directory",
    "path": "",
    "urlPath": "/",
    "include": true,
    "children": [
      {
        "id": "readme",
        "name": "readme",
        "displayName": "README",
        "type": "file",
        "order": 6,
        "path": "readme",
        "urlPath": "/readme",
        "content": "# {{appName:Your app name}}\n\nWelcome to {{appName:Your app name}}, a modern full-stack web application built with cutting-edge technologies and best practices.\n\n<!-- section-1 -->\n\n## Technology Stack\n\nThis project is built with a carefully selected stack of modern web technologies:\n\n<!-- section-2 -->\n\n## Project Structure\n\n<!-- component-AppStructureAscii -->\n\n## Quick Start\n\n<!-- section-4 -->\n\n## Credits\n\nThis foundational app structure and comprehensive documentation was generated at [Gazzola.dev](https://Gazzola.dev).\n",
        "components": [
          {
            "id": "component-AppStructureAscii",
            "name": "AppStructureAscii",
            "displayName": "AppStructureAscii",
            "type": "component",
            "path": "readme.component.AppStructureAscii",
            "urlPath": "",
            "componentId": "AppStructureAscii",
            "include": true
          }
        ],
        "sections": {
          "section1": {
            "option1": {
              "content": "This application provides a complete foundation for building modern web applications without requiring database infrastructure. All features run entirely on the client and serverless edge functions.",
              "include": true
            },
            "option2": {
              "content": "This application uses NeonDB serverless PostgreSQL for data persistence and Better Auth for secure authentication and session management. The database is managed through Prisma ORM, providing type-safe database operations and schema migrations.",
              "include": true
            },
            "option3": {
              "content": "This application uses Supabase for authentication and session management, providing secure user authentication with support for multiple authentication methods. The Supabase client handles all authentication flows and session persistence.",
              "include": true
            },
            "option4": {
              "content": "This application uses Supabase for database operations, real-time subscriptions, and file storage, combined with Better Auth for enhanced authentication features and session management. This powerful combination provides enterprise-grade security with flexible authentication options.",
              "include": true
            }
          },
          "section2": {
            "option1": {
              "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
              "include": true
            },
            "option2": {
              "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
              "include": true
            },
            "option3": {
              "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
              "include": true
            },
            "option4": {
              "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
              "include": true
            },
            "option5": {
              "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
              "include": true
            },
            "option6": {
              "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
              "include": true
            },
            "option7": {
              "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
              "include": true
            },
            "option8": {
              "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
              "include": true
            },
            "option9": {
              "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
              "include": true
            },
            "option10": {
              "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
              "include": true
            },
            "option11": {
              "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
              "include": true
            },
            "option12": {
              "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
              "include": true
            },
            "option13": {
              "content": "**Playwright**: End-to-end testing framework for automated browser testing and quality assurance.",
              "include": true
            },
            "option14": {
              "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
              "include": true
            },
            "option15": {
              "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
              "include": true
            },
            "option16": {
              "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
              "include": true
            },
            "option17": {
              "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
              "include": true
            },
            "option18": {
              "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
              "include": true
            },
            "option19": {
              "content": "**TypeScript**: Strongly-typed programming language built on JavaScript, providing enhanced code quality, developer experience, and compile-time error detection.",
              "include": true
            }
          },
          "section4": {
            "option1": {
              "content": "### Supabase Setup\n\n1. Create a project at [supabase.com](https://supabase.com)\n2. Get your project URL and anon key from Settings > API\n3. Add to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your_project_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key\n   ```\n4. Run database migrations if using Supabase for database operations",
              "include": true
            },
            "option2": {
              "content": "### NeonDB Setup\n\n1. Create a database at [neon.tech](https://neon.tech)\n2. Copy your connection string from the dashboard\n3. Add to `.env.local`:\n   ```\n   DATABASE_URL=your_connection_string\n   ```\n4. Run Prisma migrations: `npx prisma migrate dev`",
              "include": true
            },
            "option3": {
              "content": "### Prisma Setup\n\n1. Ensure your database connection string is set in `.env.local`\n2. Generate Prisma client: `npx prisma generate`\n3. Run migrations: `npx prisma migrate dev`\n4. (Optional) Seed database: `npx prisma db seed`",
              "include": true
            },
            "option4": {
              "content": "### Better Auth Setup\n\n1. Generate a secret key: `openssl rand -base64 32`\n2. Add to `.env.local`:\n   ```\n   BETTER_AUTH_SECRET=your_generated_secret\n   BETTER_AUTH_URL=http://localhost:3000\n   ```\n3. Configure authentication providers in `lib/auth.ts`\n4. Run database migrations to create auth tables",
              "include": true
            },
            "option5": {
              "content": "### Stripe Setup\n\n1. Create an account at [stripe.com](https://stripe.com)\n2. Get your API keys from Dashboard > Developers > API keys\n3. Add to `.env.local`:\n   ```\n   STRIPE_SECRET_KEY=your_secret_key\n   NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your_publishable_key\n   STRIPE_WEBHOOK_SECRET=your_webhook_secret\n   ```\n4. Set up webhooks for payment events",
              "include": true
            },
            "option6": {
              "content": "### PayPal Setup\n\n1. Create a developer account at [developer.paypal.com](https://developer.paypal.com)\n2. Create a REST API app and get your credentials\n3. Add to `.env.local`:\n   ```\n   PAYPAL_CLIENT_ID=your_client_id\n   PAYPAL_CLIENT_SECRET=your_client_secret\n   ```\n4. Configure webhook endpoints for payment notifications",
              "include": true
            },
            "option7": {
              "content": "### Resend Setup\n\n1. Create an account at [resend.com](https://resend.com)\n2. Get your API key from Settings > API Keys\n3. Add to `.env.local`:\n   ```\n   RESEND_API_KEY=your_api_key\n   ```\n4. Verify your sending domain in the Resend dashboard",
              "include": true
            },
            "option8": {
              "content": "### OpenRouter Setup\n\n1. Create an account at [openrouter.ai](https://openrouter.ai)\n2. Get your API key from Settings > API Keys\n3. Add to `.env.local`:\n   ```\n   OPENROUTER_API_KEY=your_api_key\n   ```\n4. Configure your preferred AI models in the application",
              "include": true
            }
          }
        },
        "include": true,
        "visibleAfterPage": "start-here.next-steps"
      },
      {
        "id": "robots",
        "name": "robots",
        "displayName": "ROBOTS",
        "type": "file",
        "order": 7,
        "path": "robots",
        "urlPath": "/robots",
        "content": "# ROBOTS.md\n\nThe web app has been initialized with \\`npx create-next-app@latest\\`.\nThis ROBOTS file is located at \\`roadmap/ROBOTS.md\\`. The roadmap directory is in the root of the Next.js repository.\n\n## Overview\n\nThe files in the roadmap directory should all be copied into their corresponding file paths in the next.js repo. Ie the file at \\`roadmap/app/globals.css\\` should be copied to \\`app/globals.css\\`, replacing any existing file at that location.\n\nAfter copying the files listed below, confirm that the environment variables listed below are present - if not, request them from the user. If possible, search the latest documentation for the corresponding platforms to find out how to find the environment variables.\n\nOnce the environment variables are set and the files are in place, run the commands listed below to initialize the database and any integrations.\n\n## Files to Copy\n\n<!-- section-2 -->\n\n## Prerequisites\n\n<!-- section-3 -->\n\n## File Placement\n\n<!-- section-4 -->\n",
        "components": [],
        "sections": {
          "section2": {
            "option1": {
              "content": "The following files have been generated and are ready to copy:\n\n**Core Configuration:**\n- `package.json` - Dependencies and scripts\n- `tsconfig.json` - TypeScript configuration\n- `tailwind.config.ts` - Tailwind CSS configuration\n- `next.config.js` - Next.js configuration\n- `.env.local` - Environment variables template\n\n**Application Structure:**\n- `app/` - All application routes and layouts\n- `components/` - Reusable UI components\n- `lib/` - Utility functions and helpers\n- `hooks/` - Custom React hooks\n- `types/` - TypeScript type definitions\n\n**Testing:**\n- `__tests__/` - Test files\n- `playwright.config.ts` - Playwright configuration\n- `jest.config.js` - Jest configuration\n\n**Database (if applicable):**\n- `prisma/schema.prisma` - Prisma schema\n- `supabase/` - Supabase configuration and migrations",
              "include": true
            }
          },
          "section3": {
            "option1": {
              "content": "Before copying files, ensure the target Next.js project has been initialized:\n\n```bash\nnpx create-next-app@latest my-app\ncd my-app\n```\n\nThe `create-next-app` initialization should include:\n- TypeScript support\n- Tailwind CSS\n- App Router (not Pages Router)\n- ESLint configuration\n\nAfter initialization, you can proceed with copying the generated files.",
              "include": true
            }
          },
          "section4": {
            "option1": {
              "content": "Copy the generated files to the following locations in your Next.js project:\n\n**Root Level:**\n- Copy `package.json` → Merge with existing `package.json`\n- Copy `tsconfig.json` → Replace existing `tsconfig.json`\n- Copy `tailwind.config.ts` → Replace existing `tailwind.config.ts`\n- Copy `next.config.js` → Replace existing `next.config.js`\n- Copy `.env.local` → Create new `.env.local` (fill in actual values)\n\n**Directory Structure:**\n- Copy `app/` → Merge with existing `app/` directory\n- Copy `components/` → Create new `components/` directory\n- Copy `lib/` → Create new `lib/` directory\n- Copy `hooks/` → Create new `hooks/` directory\n- Copy `types/` → Create new `types/` directory\n\n**Testing:**\n- Copy `__tests__/` → Create new `__tests__/` directory\n- Copy `playwright.config.ts` → Create new file\n- Copy `jest.config.js` → Create new file\n\n**Database:**\n- Copy `prisma/` → Create new `prisma/` directory (if using Prisma)\n- Copy `supabase/` → Create new `supabase/` directory (if using Supabase)\n\nAfter copying files:\n1. Run `npm install` to install dependencies\n2. Run `npm run dev` to start the development server\n3. Configure environment variables in `.env.local`\n4. Run database migrations if applicable",
              "include": true
            }
          }
        },
        "include": true,
        "visibleAfterPage": "start-here.next-steps"
      },
      {
        "id": "claude",
        "name": "claude",
        "displayName": "CLAUDE",
        "type": "file",
        "order": 8,
        "path": "claude",
        "urlPath": "/claude",
        "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Core Technologies\n\n<!-- section-1 -->\n\n## Project Structure\n\n<!-- component-AppStructureAscii -->\n\n# General rules:\n\n- Don't include any comments in any files.\n- All errors should be thrown - no \"fallback\" functionality\n- Import \"cn\" from \"@/lib/utils\" to concatinate classes.\n\n# File Organization and Naming Conventions\n\n<!-- section-2 -->\n\n# Hook, action, store and type patterns\n\n<!-- section-3 -->\n\n## Example of file patterns - [\\`docs/utils.md\\`](docs/utils.md)\n\nFollow the examples outlined in [\\`docs/utils.md\\`](docs/utils.md) when working on hook, action, store or type files. The file also contains the \\`prisma-rls.ts\\` and \\`action.utils.ts\\` files for reference.\n\n# Testing\n\n<!-- section-4 -->\n\n# Console.logging\n\nAll logging should be performed using the \\`conditionalLog\\` function exported from \\`lib/log.utils.ts\\`\nThe \\`NEXT_PUBLIC_LOG_LABELS\\` variable in \\`.env.local\\` stores a comma separated string of log labels. Logs are returned if \\`NEXT_PUBLIC_LOG_LABELS=\"all\"\\`, or if \\`NEXT_PUBLIC_LOG_LABELS\\` includes the label arg in \\`conditionalLog\\`.\n",
        "components": [
          {
            "id": "component-AppStructureAscii",
            "name": "AppStructureAscii",
            "displayName": "AppStructureAscii",
            "type": "component",
            "path": "claude.component.AppStructureAscii",
            "urlPath": "",
            "componentId": "AppStructureAscii",
            "include": true
          }
        ],
        "sections": {
          "section1": {
            "option1": {
              "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
              "include": true
            },
            "option2": {
              "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
              "include": true
            },
            "option3": {
              "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
              "include": true
            },
            "option4": {
              "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
              "include": true
            },
            "option5": {
              "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
              "include": true
            },
            "option6": {
              "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
              "include": true
            },
            "option7": {
              "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
              "include": true
            },
            "option8": {
              "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
              "include": true
            },
            "option9": {
              "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
              "include": true
            },
            "option10": {
              "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
              "include": true
            },
            "option11": {
              "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
              "include": true
            },
            "option12": {
              "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
              "include": true
            },
            "option13": {
              "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
              "include": true
            },
            "option14": {
              "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
              "include": true
            },
            "option15": {
              "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
              "include": true
            },
            "option16": {
              "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
              "include": true
            },
            "option17": {
              "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
              "include": true
            }
          },
          "section2": {
            "option1": {
              "content": "Types and store files alongside ancestor files. Actions and hooks files alongside descendent files.\n\n```txt\napp/\n├── layout.tsx\n├── layout.providers.tsx\n├── layout.types.ts\n├── layout.stores.ts ◄─── useAppStore\n└── (dashboard)/\n    ├── layout.tsx\n    ├── layout.types.tsx\n    ├── layout.stores.tsx ◄─── useDashboardStore\n    ├── page.tsx              ─┐\n    ├── page.hooks.tsx         ├────► useAppStore\n    ├── Component.tsx          ├────► useDashboardStore\n    ├── Component.hooks.tsx   ─┘\n    ├── page.actions.ts\n    └── Component.actions.ts\n\n    key:\n    ◄─── = defined\n    ───► = imported\n```",
              "include": true
            },
            "option2": {
              "content": "<!-- component-AppStructureAscii -->",
              "include": true
            }
          },
          "section3": {
            "option1": {
              "content": "**Client-side only (No database)**\n\nComponent <-> hook <-> store\n\n- React Query hooks fetch data from external APIs or manage client-side state.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.",
              "include": true
            },
            "option2": {
              "content": "**NeonDB + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
              "include": true
            },
            "option3": {
              "content": "**Supabase + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
              "include": true
            },
            "option4": {
              "content": "**Supabase only (Supabase Auth)**\n\nDB <-> Supabase Client <-> hook <-> store\n\n- Supabase client queries are called directly in react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `@/integrations/supabase/types`.",
              "include": true
            }
          },
          "section4": {
            "option1": {
              "content": "All tests should be performed with Playwright and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
              "include": true
            },
            "option2": {
              "content": "All tests should be performed with Playwright or Cypress and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
              "include": true
            }
          }
        },
        "include": true,
        "visibleAfterPage": "start-here.next-steps"
      },
      {
        "id": "code-files",
        "name": "code-files",
        "displayName": "Code files",
        "type": "directory",
        "path": "code-files",
        "urlPath": "/code-files",
        "include": true,
        "children": []
      },
      {
        "id": "docs",
        "name": "docs",
        "displayName": "docs",
        "type": "directory",
        "path": "docs",
        "urlPath": "/docs",
        "include": true,
        "children": [
          {
            "id": "docs.deployment-instructions",
            "name": "deployment-instructions",
            "displayName": "Deployment instructions",
            "type": "file",
            "order": 9,
            "path": "docs.deployment-instructions",
            "urlPath": "/docs/deployment-instructions",
            "content": "",
            "components": [],
            "sections": {},
            "include": true,
            "visibleAfterPage": "start-here.next-steps"
          },
          {
            "id": "docs.util",
            "name": "util",
            "displayName": "util",
            "type": "file",
            "order": 10,
            "path": "docs.util",
            "urlPath": "/docs/util",
            "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
            "components": [],
            "sections": {
              "section1": {
                "option1": {
                  "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
                  "include": true
                },
                "option2": {
                  "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
                  "include": true
                }
              },
              "section2": {
                "option1": {
                  "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
                  "include": true
                }
              },
              "section3": {
                "option1": {
                  "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
                  "include": true
                },
                "option2": {
                  "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                  "include": true
                },
                "option3": {
                  "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                  "include": true
                },
                "option4": {
                  "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                  "include": true
                }
              },
              "section4": {
                "option1": {
                  "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
                  "include": true
                },
                "option2": {
                  "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
                  "include": true
                },
                "option3": {
                  "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
                  "include": true
                }
              },
              "section5": {
                "option1": {
                  "content": "**No utility files needed for client-side only applications.**",
                  "include": true
                },
                "option2": {
                  "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                  "include": true
                },
                "option3": {
                  "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                  "include": true
                }
              }
            },
            "include": true,
            "visibleAfterPage": "start-here.next-steps"
          }
        ]
      },
      {
        "id": "start-here",
        "name": "start-here",
        "displayName": "Start here",
        "type": "directory",
        "path": "start-here",
        "urlPath": "/start-here",
        "include": true,
        "children": [
          {
            "id": "start-here.tech-stack",
            "name": "tech-stack",
            "displayName": "Tech Stack",
            "type": "file",
            "order": 1,
            "path": "start-here.tech-stack",
            "urlPath": "/start-here/tech-stack",
            "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
            "components": [
              {
                "id": "component-InitialConfiguration",
                "name": "InitialConfiguration",
                "displayName": "InitialConfiguration",
                "type": "component",
                "path": "tech-stack.component.InitialConfiguration",
                "urlPath": "",
                "componentId": "InitialConfiguration",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.theme",
            "name": "theme",
            "displayName": "Theme",
            "type": "file",
            "order": 2,
            "path": "start-here.theme",
            "urlPath": "/start-here/theme",
            "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
            "components": [
              {
                "id": "component-ThemeConfiguration",
                "name": "ThemeConfiguration",
                "displayName": "ThemeConfiguration",
                "type": "component",
                "path": "theme.component.ThemeConfiguration",
                "urlPath": "",
                "componentId": "ThemeConfiguration",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.layout-routes",
            "name": "layout-routes",
            "displayName": "Layout & routes",
            "type": "file",
            "order": 3,
            "path": "start-here.layout-routes",
            "urlPath": "/start-here/layout-routes",
            "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
            "components": [
              {
                "id": "component-LayoutAndStructure",
                "name": "LayoutAndStructure",
                "displayName": "LayoutAndStructure",
                "type": "component",
                "path": "layout-routes.component.LayoutAndStructure",
                "urlPath": "",
                "componentId": "LayoutAndStructure",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.database",
            "name": "database",
            "displayName": "Database",
            "type": "file",
            "order": 4,
            "path": "start-here.database",
            "urlPath": "/start-here/database",
            "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
            "components": [
              {
                "id": "component-DatabaseConfiguration",
                "name": "DatabaseConfiguration",
                "displayName": "DatabaseConfiguration",
                "type": "component",
                "path": "database.component.DatabaseConfiguration",
                "urlPath": "",
                "componentId": "DatabaseConfiguration",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.next-steps",
            "name": "next-steps",
            "displayName": "Next Steps",
            "type": "file",
            "order": 5,
            "path": "start-here.next-steps",
            "urlPath": "/start-here/next-steps",
            "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
            "components": [],
            "sections": {},
            "include": true
          }
        ]
      }
    ]
  },
  "flatIndex": {
    "": {
      "id": "root",
      "name": "root",
      "displayName": "Root",
      "type": "directory",
      "path": "",
      "urlPath": "/",
      "include": true,
      "children": [
        {
          "id": "readme",
          "name": "readme",
          "displayName": "README",
          "type": "file",
          "order": 6,
          "path": "readme",
          "urlPath": "/readme",
          "content": "# {{appName:Your app name}}\n\nWelcome to {{appName:Your app name}}, a modern full-stack web application built with cutting-edge technologies and best practices.\n\n<!-- section-1 -->\n\n## Technology Stack\n\nThis project is built with a carefully selected stack of modern web technologies:\n\n<!-- section-2 -->\n\n## Project Structure\n\n<!-- component-AppStructureAscii -->\n\n## Quick Start\n\n<!-- section-4 -->\n\n## Credits\n\nThis foundational app structure and comprehensive documentation was generated at [Gazzola.dev](https://Gazzola.dev).\n",
          "components": [
            {
              "id": "component-AppStructureAscii",
              "name": "AppStructureAscii",
              "displayName": "AppStructureAscii",
              "type": "component",
              "path": "readme.component.AppStructureAscii",
              "urlPath": "",
              "componentId": "AppStructureAscii",
              "include": true
            }
          ],
          "sections": {
            "section1": {
              "option1": {
                "content": "This application provides a complete foundation for building modern web applications without requiring database infrastructure. All features run entirely on the client and serverless edge functions.",
                "include": true
              },
              "option2": {
                "content": "This application uses NeonDB serverless PostgreSQL for data persistence and Better Auth for secure authentication and session management. The database is managed through Prisma ORM, providing type-safe database operations and schema migrations.",
                "include": true
              },
              "option3": {
                "content": "This application uses Supabase for authentication and session management, providing secure user authentication with support for multiple authentication methods. The Supabase client handles all authentication flows and session persistence.",
                "include": true
              },
              "option4": {
                "content": "This application uses Supabase for database operations, real-time subscriptions, and file storage, combined with Better Auth for enhanced authentication features and session management. This powerful combination provides enterprise-grade security with flexible authentication options.",
                "include": true
              }
            },
            "section2": {
              "option1": {
                "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
                "include": true
              },
              "option2": {
                "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
                "include": true
              },
              "option3": {
                "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
                "include": true
              },
              "option4": {
                "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
                "include": true
              },
              "option5": {
                "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
                "include": true
              },
              "option6": {
                "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
                "include": true
              },
              "option7": {
                "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
                "include": true
              },
              "option8": {
                "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
                "include": true
              },
              "option9": {
                "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
                "include": true
              },
              "option10": {
                "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
                "include": true
              },
              "option11": {
                "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
                "include": true
              },
              "option12": {
                "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
                "include": true
              },
              "option13": {
                "content": "**Playwright**: End-to-end testing framework for automated browser testing and quality assurance.",
                "include": true
              },
              "option14": {
                "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
                "include": true
              },
              "option15": {
                "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
                "include": true
              },
              "option16": {
                "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
                "include": true
              },
              "option17": {
                "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
                "include": true
              },
              "option18": {
                "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
                "include": true
              },
              "option19": {
                "content": "**TypeScript**: Strongly-typed programming language built on JavaScript, providing enhanced code quality, developer experience, and compile-time error detection.",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "### Supabase Setup\n\n1. Create a project at [supabase.com](https://supabase.com)\n2. Get your project URL and anon key from Settings > API\n3. Add to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your_project_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key\n   ```\n4. Run database migrations if using Supabase for database operations",
                "include": true
              },
              "option2": {
                "content": "### NeonDB Setup\n\n1. Create a database at [neon.tech](https://neon.tech)\n2. Copy your connection string from the dashboard\n3. Add to `.env.local`:\n   ```\n   DATABASE_URL=your_connection_string\n   ```\n4. Run Prisma migrations: `npx prisma migrate dev`",
                "include": true
              },
              "option3": {
                "content": "### Prisma Setup\n\n1. Ensure your database connection string is set in `.env.local`\n2. Generate Prisma client: `npx prisma generate`\n3. Run migrations: `npx prisma migrate dev`\n4. (Optional) Seed database: `npx prisma db seed`",
                "include": true
              },
              "option4": {
                "content": "### Better Auth Setup\n\n1. Generate a secret key: `openssl rand -base64 32`\n2. Add to `.env.local`:\n   ```\n   BETTER_AUTH_SECRET=your_generated_secret\n   BETTER_AUTH_URL=http://localhost:3000\n   ```\n3. Configure authentication providers in `lib/auth.ts`\n4. Run database migrations to create auth tables",
                "include": true
              },
              "option5": {
                "content": "### Stripe Setup\n\n1. Create an account at [stripe.com](https://stripe.com)\n2. Get your API keys from Dashboard > Developers > API keys\n3. Add to `.env.local`:\n   ```\n   STRIPE_SECRET_KEY=your_secret_key\n   NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your_publishable_key\n   STRIPE_WEBHOOK_SECRET=your_webhook_secret\n   ```\n4. Set up webhooks for payment events",
                "include": true
              },
              "option6": {
                "content": "### PayPal Setup\n\n1. Create a developer account at [developer.paypal.com](https://developer.paypal.com)\n2. Create a REST API app and get your credentials\n3. Add to `.env.local`:\n   ```\n   PAYPAL_CLIENT_ID=your_client_id\n   PAYPAL_CLIENT_SECRET=your_client_secret\n   ```\n4. Configure webhook endpoints for payment notifications",
                "include": true
              },
              "option7": {
                "content": "### Resend Setup\n\n1. Create an account at [resend.com](https://resend.com)\n2. Get your API key from Settings > API Keys\n3. Add to `.env.local`:\n   ```\n   RESEND_API_KEY=your_api_key\n   ```\n4. Verify your sending domain in the Resend dashboard",
                "include": true
              },
              "option8": {
                "content": "### OpenRouter Setup\n\n1. Create an account at [openrouter.ai](https://openrouter.ai)\n2. Get your API key from Settings > API Keys\n3. Add to `.env.local`:\n   ```\n   OPENROUTER_API_KEY=your_api_key\n   ```\n4. Configure your preferred AI models in the application",
                "include": true
              }
            }
          },
          "include": true,
          "visibleAfterPage": "start-here.next-steps"
        },
        {
          "id": "robots",
          "name": "robots",
          "displayName": "ROBOTS",
          "type": "file",
          "order": 7,
          "path": "robots",
          "urlPath": "/robots",
          "content": "# ROBOTS.md\n\nThe web app has been initialized with \\`npx create-next-app@latest\\`.\nThis ROBOTS file is located at \\`roadmap/ROBOTS.md\\`. The roadmap directory is in the root of the Next.js repository.\n\n## Overview\n\nThe files in the roadmap directory should all be copied into their corresponding file paths in the next.js repo. Ie the file at \\`roadmap/app/globals.css\\` should be copied to \\`app/globals.css\\`, replacing any existing file at that location.\n\nAfter copying the files listed below, confirm that the environment variables listed below are present - if not, request them from the user. If possible, search the latest documentation for the corresponding platforms to find out how to find the environment variables.\n\nOnce the environment variables are set and the files are in place, run the commands listed below to initialize the database and any integrations.\n\n## Files to Copy\n\n<!-- section-2 -->\n\n## Prerequisites\n\n<!-- section-3 -->\n\n## File Placement\n\n<!-- section-4 -->\n",
          "components": [],
          "sections": {
            "section2": {
              "option1": {
                "content": "The following files have been generated and are ready to copy:\n\n**Core Configuration:**\n- `package.json` - Dependencies and scripts\n- `tsconfig.json` - TypeScript configuration\n- `tailwind.config.ts` - Tailwind CSS configuration\n- `next.config.js` - Next.js configuration\n- `.env.local` - Environment variables template\n\n**Application Structure:**\n- `app/` - All application routes and layouts\n- `components/` - Reusable UI components\n- `lib/` - Utility functions and helpers\n- `hooks/` - Custom React hooks\n- `types/` - TypeScript type definitions\n\n**Testing:**\n- `__tests__/` - Test files\n- `playwright.config.ts` - Playwright configuration\n- `jest.config.js` - Jest configuration\n\n**Database (if applicable):**\n- `prisma/schema.prisma` - Prisma schema\n- `supabase/` - Supabase configuration and migrations",
                "include": true
              }
            },
            "section3": {
              "option1": {
                "content": "Before copying files, ensure the target Next.js project has been initialized:\n\n```bash\nnpx create-next-app@latest my-app\ncd my-app\n```\n\nThe `create-next-app` initialization should include:\n- TypeScript support\n- Tailwind CSS\n- App Router (not Pages Router)\n- ESLint configuration\n\nAfter initialization, you can proceed with copying the generated files.",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "Copy the generated files to the following locations in your Next.js project:\n\n**Root Level:**\n- Copy `package.json` → Merge with existing `package.json`\n- Copy `tsconfig.json` → Replace existing `tsconfig.json`\n- Copy `tailwind.config.ts` → Replace existing `tailwind.config.ts`\n- Copy `next.config.js` → Replace existing `next.config.js`\n- Copy `.env.local` → Create new `.env.local` (fill in actual values)\n\n**Directory Structure:**\n- Copy `app/` → Merge with existing `app/` directory\n- Copy `components/` → Create new `components/` directory\n- Copy `lib/` → Create new `lib/` directory\n- Copy `hooks/` → Create new `hooks/` directory\n- Copy `types/` → Create new `types/` directory\n\n**Testing:**\n- Copy `__tests__/` → Create new `__tests__/` directory\n- Copy `playwright.config.ts` → Create new file\n- Copy `jest.config.js` → Create new file\n\n**Database:**\n- Copy `prisma/` → Create new `prisma/` directory (if using Prisma)\n- Copy `supabase/` → Create new `supabase/` directory (if using Supabase)\n\nAfter copying files:\n1. Run `npm install` to install dependencies\n2. Run `npm run dev` to start the development server\n3. Configure environment variables in `.env.local`\n4. Run database migrations if applicable",
                "include": true
              }
            }
          },
          "include": true,
          "visibleAfterPage": "start-here.next-steps"
        },
        {
          "id": "claude",
          "name": "claude",
          "displayName": "CLAUDE",
          "type": "file",
          "order": 8,
          "path": "claude",
          "urlPath": "/claude",
          "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Core Technologies\n\n<!-- section-1 -->\n\n## Project Structure\n\n<!-- component-AppStructureAscii -->\n\n# General rules:\n\n- Don't include any comments in any files.\n- All errors should be thrown - no \"fallback\" functionality\n- Import \"cn\" from \"@/lib/utils\" to concatinate classes.\n\n# File Organization and Naming Conventions\n\n<!-- section-2 -->\n\n# Hook, action, store and type patterns\n\n<!-- section-3 -->\n\n## Example of file patterns - [\\`docs/utils.md\\`](docs/utils.md)\n\nFollow the examples outlined in [\\`docs/utils.md\\`](docs/utils.md) when working on hook, action, store or type files. The file also contains the \\`prisma-rls.ts\\` and \\`action.utils.ts\\` files for reference.\n\n# Testing\n\n<!-- section-4 -->\n\n# Console.logging\n\nAll logging should be performed using the \\`conditionalLog\\` function exported from \\`lib/log.utils.ts\\`\nThe \\`NEXT_PUBLIC_LOG_LABELS\\` variable in \\`.env.local\\` stores a comma separated string of log labels. Logs are returned if \\`NEXT_PUBLIC_LOG_LABELS=\"all\"\\`, or if \\`NEXT_PUBLIC_LOG_LABELS\\` includes the label arg in \\`conditionalLog\\`.\n",
          "components": [
            {
              "id": "component-AppStructureAscii",
              "name": "AppStructureAscii",
              "displayName": "AppStructureAscii",
              "type": "component",
              "path": "claude.component.AppStructureAscii",
              "urlPath": "",
              "componentId": "AppStructureAscii",
              "include": true
            }
          ],
          "sections": {
            "section1": {
              "option1": {
                "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
                "include": true
              },
              "option2": {
                "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
                "include": true
              },
              "option3": {
                "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
                "include": true
              },
              "option4": {
                "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
                "include": true
              },
              "option5": {
                "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
                "include": true
              },
              "option6": {
                "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
                "include": true
              },
              "option7": {
                "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
                "include": true
              },
              "option8": {
                "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
                "include": true
              },
              "option9": {
                "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
                "include": true
              },
              "option10": {
                "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
                "include": true
              },
              "option11": {
                "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
                "include": true
              },
              "option12": {
                "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
                "include": true
              },
              "option13": {
                "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
                "include": true
              },
              "option14": {
                "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
                "include": true
              },
              "option15": {
                "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
                "include": true
              },
              "option16": {
                "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
                "include": true
              },
              "option17": {
                "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
                "include": true
              }
            },
            "section2": {
              "option1": {
                "content": "Types and store files alongside ancestor files. Actions and hooks files alongside descendent files.\n\n```txt\napp/\n├── layout.tsx\n├── layout.providers.tsx\n├── layout.types.ts\n├── layout.stores.ts ◄─── useAppStore\n└── (dashboard)/\n    ├── layout.tsx\n    ├── layout.types.tsx\n    ├── layout.stores.tsx ◄─── useDashboardStore\n    ├── page.tsx              ─┐\n    ├── page.hooks.tsx         ├────► useAppStore\n    ├── Component.tsx          ├────► useDashboardStore\n    ├── Component.hooks.tsx   ─┘\n    ├── page.actions.ts\n    └── Component.actions.ts\n\n    key:\n    ◄─── = defined\n    ───► = imported\n```",
                "include": true
              },
              "option2": {
                "content": "<!-- component-AppStructureAscii -->",
                "include": true
              }
            },
            "section3": {
              "option1": {
                "content": "**Client-side only (No database)**\n\nComponent <-> hook <-> store\n\n- React Query hooks fetch data from external APIs or manage client-side state.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.",
                "include": true
              },
              "option2": {
                "content": "**NeonDB + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
                "include": true
              },
              "option3": {
                "content": "**Supabase + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
                "include": true
              },
              "option4": {
                "content": "**Supabase only (Supabase Auth)**\n\nDB <-> Supabase Client <-> hook <-> store\n\n- Supabase client queries are called directly in react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `@/integrations/supabase/types`.",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "All tests should be performed with Playwright and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
                "include": true
              },
              "option2": {
                "content": "All tests should be performed with Playwright or Cypress and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
                "include": true
              }
            }
          },
          "include": true,
          "visibleAfterPage": "start-here.next-steps"
        },
        {
          "id": "code-files",
          "name": "code-files",
          "displayName": "Code files",
          "type": "directory",
          "path": "code-files",
          "urlPath": "/code-files",
          "include": true,
          "children": []
        },
        {
          "id": "docs",
          "name": "docs",
          "displayName": "docs",
          "type": "directory",
          "path": "docs",
          "urlPath": "/docs",
          "include": true,
          "children": [
            {
              "id": "docs.deployment-instructions",
              "name": "deployment-instructions",
              "displayName": "Deployment instructions",
              "type": "file",
              "order": 9,
              "path": "docs.deployment-instructions",
              "urlPath": "/docs/deployment-instructions",
              "content": "",
              "components": [],
              "sections": {},
              "include": true,
              "visibleAfterPage": "start-here.next-steps"
            },
            {
              "id": "docs.util",
              "name": "util",
              "displayName": "util",
              "type": "file",
              "order": 10,
              "path": "docs.util",
              "urlPath": "/docs/util",
              "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
              "components": [],
              "sections": {
                "section1": {
                  "option1": {
                    "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
                    "include": true
                  },
                  "option2": {
                    "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
                    "include": true
                  }
                },
                "section2": {
                  "option1": {
                    "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
                    "include": true
                  }
                },
                "section3": {
                  "option1": {
                    "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
                    "include": true
                  },
                  "option2": {
                    "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                    "include": true
                  },
                  "option3": {
                    "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                    "include": true
                  },
                  "option4": {
                    "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                    "include": true
                  }
                },
                "section4": {
                  "option1": {
                    "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
                    "include": true
                  },
                  "option2": {
                    "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
                    "include": true
                  },
                  "option3": {
                    "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
                    "include": true
                  }
                },
                "section5": {
                  "option1": {
                    "content": "**No utility files needed for client-side only applications.**",
                    "include": true
                  },
                  "option2": {
                    "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                    "include": true
                  },
                  "option3": {
                    "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                    "include": true
                  }
                }
              },
              "include": true,
              "visibleAfterPage": "start-here.next-steps"
            }
          ]
        },
        {
          "id": "start-here",
          "name": "start-here",
          "displayName": "Start here",
          "type": "directory",
          "path": "start-here",
          "urlPath": "/start-here",
          "include": true,
          "children": [
            {
              "id": "start-here.tech-stack",
              "name": "tech-stack",
              "displayName": "Tech Stack",
              "type": "file",
              "order": 1,
              "path": "start-here.tech-stack",
              "urlPath": "/start-here/tech-stack",
              "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
              "components": [
                {
                  "id": "component-InitialConfiguration",
                  "name": "InitialConfiguration",
                  "displayName": "InitialConfiguration",
                  "type": "component",
                  "path": "tech-stack.component.InitialConfiguration",
                  "urlPath": "",
                  "componentId": "InitialConfiguration",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.theme",
              "name": "theme",
              "displayName": "Theme",
              "type": "file",
              "order": 2,
              "path": "start-here.theme",
              "urlPath": "/start-here/theme",
              "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
              "components": [
                {
                  "id": "component-ThemeConfiguration",
                  "name": "ThemeConfiguration",
                  "displayName": "ThemeConfiguration",
                  "type": "component",
                  "path": "theme.component.ThemeConfiguration",
                  "urlPath": "",
                  "componentId": "ThemeConfiguration",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.layout-routes",
              "name": "layout-routes",
              "displayName": "Layout & routes",
              "type": "file",
              "order": 3,
              "path": "start-here.layout-routes",
              "urlPath": "/start-here/layout-routes",
              "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
              "components": [
                {
                  "id": "component-LayoutAndStructure",
                  "name": "LayoutAndStructure",
                  "displayName": "LayoutAndStructure",
                  "type": "component",
                  "path": "layout-routes.component.LayoutAndStructure",
                  "urlPath": "",
                  "componentId": "LayoutAndStructure",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.database",
              "name": "database",
              "displayName": "Database",
              "type": "file",
              "order": 4,
              "path": "start-here.database",
              "urlPath": "/start-here/database",
              "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
              "components": [
                {
                  "id": "component-DatabaseConfiguration",
                  "name": "DatabaseConfiguration",
                  "displayName": "DatabaseConfiguration",
                  "type": "component",
                  "path": "database.component.DatabaseConfiguration",
                  "urlPath": "",
                  "componentId": "DatabaseConfiguration",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.next-steps",
              "name": "next-steps",
              "displayName": "Next Steps",
              "type": "file",
              "order": 5,
              "path": "start-here.next-steps",
              "urlPath": "/start-here/next-steps",
              "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
              "components": [],
              "sections": {},
              "include": true
            }
          ]
        }
      ]
    },
    "readme": {
      "id": "readme",
      "name": "readme",
      "displayName": "README",
      "type": "file",
      "order": 6,
      "path": "readme",
      "urlPath": "/readme",
      "content": "# {{appName:Your app name}}\n\nWelcome to {{appName:Your app name}}, a modern full-stack web application built with cutting-edge technologies and best practices.\n\n<!-- section-1 -->\n\n## Technology Stack\n\nThis project is built with a carefully selected stack of modern web technologies:\n\n<!-- section-2 -->\n\n## Project Structure\n\n<!-- component-AppStructureAscii -->\n\n## Quick Start\n\n<!-- section-4 -->\n\n## Credits\n\nThis foundational app structure and comprehensive documentation was generated at [Gazzola.dev](https://Gazzola.dev).\n",
      "components": [
        {
          "id": "component-AppStructureAscii",
          "name": "AppStructureAscii",
          "displayName": "AppStructureAscii",
          "type": "component",
          "path": "readme.component.AppStructureAscii",
          "urlPath": "",
          "componentId": "AppStructureAscii",
          "include": true
        }
      ],
      "sections": {
        "section1": {
          "option1": {
            "content": "This application provides a complete foundation for building modern web applications without requiring database infrastructure. All features run entirely on the client and serverless edge functions.",
            "include": true
          },
          "option2": {
            "content": "This application uses NeonDB serverless PostgreSQL for data persistence and Better Auth for secure authentication and session management. The database is managed through Prisma ORM, providing type-safe database operations and schema migrations.",
            "include": true
          },
          "option3": {
            "content": "This application uses Supabase for authentication and session management, providing secure user authentication with support for multiple authentication methods. The Supabase client handles all authentication flows and session persistence.",
            "include": true
          },
          "option4": {
            "content": "This application uses Supabase for database operations, real-time subscriptions, and file storage, combined with Better Auth for enhanced authentication features and session management. This powerful combination provides enterprise-grade security with flexible authentication options.",
            "include": true
          }
        },
        "section2": {
          "option1": {
            "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
            "include": true
          },
          "option2": {
            "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
            "include": true
          },
          "option3": {
            "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
            "include": true
          },
          "option4": {
            "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
            "include": true
          },
          "option5": {
            "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
            "include": true
          },
          "option6": {
            "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
            "include": true
          },
          "option7": {
            "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
            "include": true
          },
          "option8": {
            "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
            "include": true
          },
          "option9": {
            "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
            "include": true
          },
          "option10": {
            "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
            "include": true
          },
          "option11": {
            "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
            "include": true
          },
          "option12": {
            "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
            "include": true
          },
          "option13": {
            "content": "**Playwright**: End-to-end testing framework for automated browser testing and quality assurance.",
            "include": true
          },
          "option14": {
            "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
            "include": true
          },
          "option15": {
            "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
            "include": true
          },
          "option16": {
            "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
            "include": true
          },
          "option17": {
            "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
            "include": true
          },
          "option18": {
            "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
            "include": true
          },
          "option19": {
            "content": "**TypeScript**: Strongly-typed programming language built on JavaScript, providing enhanced code quality, developer experience, and compile-time error detection.",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "### Supabase Setup\n\n1. Create a project at [supabase.com](https://supabase.com)\n2. Get your project URL and anon key from Settings > API\n3. Add to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your_project_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key\n   ```\n4. Run database migrations if using Supabase for database operations",
            "include": true
          },
          "option2": {
            "content": "### NeonDB Setup\n\n1. Create a database at [neon.tech](https://neon.tech)\n2. Copy your connection string from the dashboard\n3. Add to `.env.local`:\n   ```\n   DATABASE_URL=your_connection_string\n   ```\n4. Run Prisma migrations: `npx prisma migrate dev`",
            "include": true
          },
          "option3": {
            "content": "### Prisma Setup\n\n1. Ensure your database connection string is set in `.env.local`\n2. Generate Prisma client: `npx prisma generate`\n3. Run migrations: `npx prisma migrate dev`\n4. (Optional) Seed database: `npx prisma db seed`",
            "include": true
          },
          "option4": {
            "content": "### Better Auth Setup\n\n1. Generate a secret key: `openssl rand -base64 32`\n2. Add to `.env.local`:\n   ```\n   BETTER_AUTH_SECRET=your_generated_secret\n   BETTER_AUTH_URL=http://localhost:3000\n   ```\n3. Configure authentication providers in `lib/auth.ts`\n4. Run database migrations to create auth tables",
            "include": true
          },
          "option5": {
            "content": "### Stripe Setup\n\n1. Create an account at [stripe.com](https://stripe.com)\n2. Get your API keys from Dashboard > Developers > API keys\n3. Add to `.env.local`:\n   ```\n   STRIPE_SECRET_KEY=your_secret_key\n   NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your_publishable_key\n   STRIPE_WEBHOOK_SECRET=your_webhook_secret\n   ```\n4. Set up webhooks for payment events",
            "include": true
          },
          "option6": {
            "content": "### PayPal Setup\n\n1. Create a developer account at [developer.paypal.com](https://developer.paypal.com)\n2. Create a REST API app and get your credentials\n3. Add to `.env.local`:\n   ```\n   PAYPAL_CLIENT_ID=your_client_id\n   PAYPAL_CLIENT_SECRET=your_client_secret\n   ```\n4. Configure webhook endpoints for payment notifications",
            "include": true
          },
          "option7": {
            "content": "### Resend Setup\n\n1. Create an account at [resend.com](https://resend.com)\n2. Get your API key from Settings > API Keys\n3. Add to `.env.local`:\n   ```\n   RESEND_API_KEY=your_api_key\n   ```\n4. Verify your sending domain in the Resend dashboard",
            "include": true
          },
          "option8": {
            "content": "### OpenRouter Setup\n\n1. Create an account at [openrouter.ai](https://openrouter.ai)\n2. Get your API key from Settings > API Keys\n3. Add to `.env.local`:\n   ```\n   OPENROUTER_API_KEY=your_api_key\n   ```\n4. Configure your preferred AI models in the application",
            "include": true
          }
        }
      },
      "include": true,
      "visibleAfterPage": "start-here.next-steps"
    },
    "readme.component.AppStructureAscii": {
      "id": "component-AppStructureAscii",
      "name": "AppStructureAscii",
      "displayName": "AppStructureAscii",
      "type": "component",
      "path": "readme.component.AppStructureAscii",
      "urlPath": "",
      "componentId": "AppStructureAscii",
      "include": true
    },
    "robots": {
      "id": "robots",
      "name": "robots",
      "displayName": "ROBOTS",
      "type": "file",
      "order": 7,
      "path": "robots",
      "urlPath": "/robots",
      "content": "# ROBOTS.md\n\nThe web app has been initialized with \\`npx create-next-app@latest\\`.\nThis ROBOTS file is located at \\`roadmap/ROBOTS.md\\`. The roadmap directory is in the root of the Next.js repository.\n\n## Overview\n\nThe files in the roadmap directory should all be copied into their corresponding file paths in the next.js repo. Ie the file at \\`roadmap/app/globals.css\\` should be copied to \\`app/globals.css\\`, replacing any existing file at that location.\n\nAfter copying the files listed below, confirm that the environment variables listed below are present - if not, request them from the user. If possible, search the latest documentation for the corresponding platforms to find out how to find the environment variables.\n\nOnce the environment variables are set and the files are in place, run the commands listed below to initialize the database and any integrations.\n\n## Files to Copy\n\n<!-- section-2 -->\n\n## Prerequisites\n\n<!-- section-3 -->\n\n## File Placement\n\n<!-- section-4 -->\n",
      "components": [],
      "sections": {
        "section2": {
          "option1": {
            "content": "The following files have been generated and are ready to copy:\n\n**Core Configuration:**\n- `package.json` - Dependencies and scripts\n- `tsconfig.json` - TypeScript configuration\n- `tailwind.config.ts` - Tailwind CSS configuration\n- `next.config.js` - Next.js configuration\n- `.env.local` - Environment variables template\n\n**Application Structure:**\n- `app/` - All application routes and layouts\n- `components/` - Reusable UI components\n- `lib/` - Utility functions and helpers\n- `hooks/` - Custom React hooks\n- `types/` - TypeScript type definitions\n\n**Testing:**\n- `__tests__/` - Test files\n- `playwright.config.ts` - Playwright configuration\n- `jest.config.js` - Jest configuration\n\n**Database (if applicable):**\n- `prisma/schema.prisma` - Prisma schema\n- `supabase/` - Supabase configuration and migrations",
            "include": true
          }
        },
        "section3": {
          "option1": {
            "content": "Before copying files, ensure the target Next.js project has been initialized:\n\n```bash\nnpx create-next-app@latest my-app\ncd my-app\n```\n\nThe `create-next-app` initialization should include:\n- TypeScript support\n- Tailwind CSS\n- App Router (not Pages Router)\n- ESLint configuration\n\nAfter initialization, you can proceed with copying the generated files.",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "Copy the generated files to the following locations in your Next.js project:\n\n**Root Level:**\n- Copy `package.json` → Merge with existing `package.json`\n- Copy `tsconfig.json` → Replace existing `tsconfig.json`\n- Copy `tailwind.config.ts` → Replace existing `tailwind.config.ts`\n- Copy `next.config.js` → Replace existing `next.config.js`\n- Copy `.env.local` → Create new `.env.local` (fill in actual values)\n\n**Directory Structure:**\n- Copy `app/` → Merge with existing `app/` directory\n- Copy `components/` → Create new `components/` directory\n- Copy `lib/` → Create new `lib/` directory\n- Copy `hooks/` → Create new `hooks/` directory\n- Copy `types/` → Create new `types/` directory\n\n**Testing:**\n- Copy `__tests__/` → Create new `__tests__/` directory\n- Copy `playwright.config.ts` → Create new file\n- Copy `jest.config.js` → Create new file\n\n**Database:**\n- Copy `prisma/` → Create new `prisma/` directory (if using Prisma)\n- Copy `supabase/` → Create new `supabase/` directory (if using Supabase)\n\nAfter copying files:\n1. Run `npm install` to install dependencies\n2. Run `npm run dev` to start the development server\n3. Configure environment variables in `.env.local`\n4. Run database migrations if applicable",
            "include": true
          }
        }
      },
      "include": true,
      "visibleAfterPage": "start-here.next-steps"
    },
    "claude": {
      "id": "claude",
      "name": "claude",
      "displayName": "CLAUDE",
      "type": "file",
      "order": 8,
      "path": "claude",
      "urlPath": "/claude",
      "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Core Technologies\n\n<!-- section-1 -->\n\n## Project Structure\n\n<!-- component-AppStructureAscii -->\n\n# General rules:\n\n- Don't include any comments in any files.\n- All errors should be thrown - no \"fallback\" functionality\n- Import \"cn\" from \"@/lib/utils\" to concatinate classes.\n\n# File Organization and Naming Conventions\n\n<!-- section-2 -->\n\n# Hook, action, store and type patterns\n\n<!-- section-3 -->\n\n## Example of file patterns - [\\`docs/utils.md\\`](docs/utils.md)\n\nFollow the examples outlined in [\\`docs/utils.md\\`](docs/utils.md) when working on hook, action, store or type files. The file also contains the \\`prisma-rls.ts\\` and \\`action.utils.ts\\` files for reference.\n\n# Testing\n\n<!-- section-4 -->\n\n# Console.logging\n\nAll logging should be performed using the \\`conditionalLog\\` function exported from \\`lib/log.utils.ts\\`\nThe \\`NEXT_PUBLIC_LOG_LABELS\\` variable in \\`.env.local\\` stores a comma separated string of log labels. Logs are returned if \\`NEXT_PUBLIC_LOG_LABELS=\"all\"\\`, or if \\`NEXT_PUBLIC_LOG_LABELS\\` includes the label arg in \\`conditionalLog\\`.\n",
      "components": [
        {
          "id": "component-AppStructureAscii",
          "name": "AppStructureAscii",
          "displayName": "AppStructureAscii",
          "type": "component",
          "path": "claude.component.AppStructureAscii",
          "urlPath": "",
          "componentId": "AppStructureAscii",
          "include": true
        }
      ],
      "sections": {
        "section1": {
          "option1": {
            "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
            "include": true
          },
          "option2": {
            "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
            "include": true
          },
          "option3": {
            "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
            "include": true
          },
          "option4": {
            "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
            "include": true
          },
          "option5": {
            "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
            "include": true
          },
          "option6": {
            "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
            "include": true
          },
          "option7": {
            "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
            "include": true
          },
          "option8": {
            "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
            "include": true
          },
          "option9": {
            "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
            "include": true
          },
          "option10": {
            "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
            "include": true
          },
          "option11": {
            "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
            "include": true
          },
          "option12": {
            "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
            "include": true
          },
          "option13": {
            "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
            "include": true
          },
          "option14": {
            "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
            "include": true
          },
          "option15": {
            "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
            "include": true
          },
          "option16": {
            "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
            "include": true
          },
          "option17": {
            "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
            "include": true
          }
        },
        "section2": {
          "option1": {
            "content": "Types and store files alongside ancestor files. Actions and hooks files alongside descendent files.\n\n```txt\napp/\n├── layout.tsx\n├── layout.providers.tsx\n├── layout.types.ts\n├── layout.stores.ts ◄─── useAppStore\n└── (dashboard)/\n    ├── layout.tsx\n    ├── layout.types.tsx\n    ├── layout.stores.tsx ◄─── useDashboardStore\n    ├── page.tsx              ─┐\n    ├── page.hooks.tsx         ├────► useAppStore\n    ├── Component.tsx          ├────► useDashboardStore\n    ├── Component.hooks.tsx   ─┘\n    ├── page.actions.ts\n    └── Component.actions.ts\n\n    key:\n    ◄─── = defined\n    ───► = imported\n```",
            "include": true
          },
          "option2": {
            "content": "<!-- component-AppStructureAscii -->",
            "include": true
          }
        },
        "section3": {
          "option1": {
            "content": "**Client-side only (No database)**\n\nComponent <-> hook <-> store\n\n- React Query hooks fetch data from external APIs or manage client-side state.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.",
            "include": true
          },
          "option2": {
            "content": "**NeonDB + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
            "include": true
          },
          "option3": {
            "content": "**Supabase + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
            "include": true
          },
          "option4": {
            "content": "**Supabase only (Supabase Auth)**\n\nDB <-> Supabase Client <-> hook <-> store\n\n- Supabase client queries are called directly in react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `@/integrations/supabase/types`.",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "All tests should be performed with Playwright and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
            "include": true
          },
          "option2": {
            "content": "All tests should be performed with Playwright or Cypress and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
            "include": true
          }
        }
      },
      "include": true,
      "visibleAfterPage": "start-here.next-steps"
    },
    "claude.component.AppStructureAscii": {
      "id": "component-AppStructureAscii",
      "name": "AppStructureAscii",
      "displayName": "AppStructureAscii",
      "type": "component",
      "path": "claude.component.AppStructureAscii",
      "urlPath": "",
      "componentId": "AppStructureAscii",
      "include": true
    },
    "code-files": {
      "id": "code-files",
      "name": "code-files",
      "displayName": "Code files",
      "type": "directory",
      "path": "code-files",
      "urlPath": "/code-files",
      "include": true,
      "children": []
    },
    "docs": {
      "id": "docs",
      "name": "docs",
      "displayName": "docs",
      "type": "directory",
      "path": "docs",
      "urlPath": "/docs",
      "include": true,
      "children": [
        {
          "id": "docs.deployment-instructions",
          "name": "deployment-instructions",
          "displayName": "Deployment instructions",
          "type": "file",
          "order": 9,
          "path": "docs.deployment-instructions",
          "urlPath": "/docs/deployment-instructions",
          "content": "",
          "components": [],
          "sections": {},
          "include": true,
          "visibleAfterPage": "start-here.next-steps"
        },
        {
          "id": "docs.util",
          "name": "util",
          "displayName": "util",
          "type": "file",
          "order": 10,
          "path": "docs.util",
          "urlPath": "/docs/util",
          "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
          "components": [],
          "sections": {
            "section1": {
              "option1": {
                "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
                "include": true
              },
              "option2": {
                "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
                "include": true
              }
            },
            "section2": {
              "option1": {
                "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
                "include": true
              }
            },
            "section3": {
              "option1": {
                "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
                "include": true
              },
              "option2": {
                "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                "include": true
              },
              "option3": {
                "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                "include": true
              },
              "option4": {
                "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
                "include": true
              },
              "option2": {
                "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
                "include": true
              },
              "option3": {
                "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
                "include": true
              }
            },
            "section5": {
              "option1": {
                "content": "**No utility files needed for client-side only applications.**",
                "include": true
              },
              "option2": {
                "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                "include": true
              },
              "option3": {
                "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                "include": true
              }
            }
          },
          "include": true,
          "visibleAfterPage": "start-here.next-steps"
        }
      ]
    },
    "docs.deployment-instructions": {
      "id": "docs.deployment-instructions",
      "name": "deployment-instructions",
      "displayName": "Deployment instructions",
      "type": "file",
      "order": 9,
      "path": "docs.deployment-instructions",
      "urlPath": "/docs/deployment-instructions",
      "content": "",
      "components": [],
      "sections": {},
      "include": true,
      "visibleAfterPage": "start-here.next-steps"
    },
    "docs.util": {
      "id": "docs.util",
      "name": "util",
      "displayName": "util",
      "type": "file",
      "order": 10,
      "path": "docs.util",
      "urlPath": "/docs/util",
      "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
      "components": [],
      "sections": {
        "section1": {
          "option1": {
            "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
            "include": true
          },
          "option2": {
            "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
            "include": true
          }
        },
        "section2": {
          "option1": {
            "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
            "include": true
          }
        },
        "section3": {
          "option1": {
            "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
            "include": true
          },
          "option2": {
            "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
            "include": true
          },
          "option3": {
            "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
            "include": true
          },
          "option4": {
            "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
            "include": true
          },
          "option2": {
            "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
            "include": true
          },
          "option3": {
            "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
            "include": true
          }
        },
        "section5": {
          "option1": {
            "content": "**No utility files needed for client-side only applications.**",
            "include": true
          },
          "option2": {
            "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
            "include": true
          },
          "option3": {
            "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
            "include": true
          }
        }
      },
      "include": true,
      "visibleAfterPage": "start-here.next-steps"
    },
    "start-here": {
      "id": "start-here",
      "name": "start-here",
      "displayName": "Start here",
      "type": "directory",
      "path": "start-here",
      "urlPath": "/start-here",
      "include": true,
      "children": [
        {
          "id": "start-here.tech-stack",
          "name": "tech-stack",
          "displayName": "Tech Stack",
          "type": "file",
          "order": 1,
          "path": "start-here.tech-stack",
          "urlPath": "/start-here/tech-stack",
          "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
          "components": [
            {
              "id": "component-InitialConfiguration",
              "name": "InitialConfiguration",
              "displayName": "InitialConfiguration",
              "type": "component",
              "path": "tech-stack.component.InitialConfiguration",
              "urlPath": "",
              "componentId": "InitialConfiguration",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.theme",
          "name": "theme",
          "displayName": "Theme",
          "type": "file",
          "order": 2,
          "path": "start-here.theme",
          "urlPath": "/start-here/theme",
          "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
          "components": [
            {
              "id": "component-ThemeConfiguration",
              "name": "ThemeConfiguration",
              "displayName": "ThemeConfiguration",
              "type": "component",
              "path": "theme.component.ThemeConfiguration",
              "urlPath": "",
              "componentId": "ThemeConfiguration",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.layout-routes",
          "name": "layout-routes",
          "displayName": "Layout & routes",
          "type": "file",
          "order": 3,
          "path": "start-here.layout-routes",
          "urlPath": "/start-here/layout-routes",
          "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
          "components": [
            {
              "id": "component-LayoutAndStructure",
              "name": "LayoutAndStructure",
              "displayName": "LayoutAndStructure",
              "type": "component",
              "path": "layout-routes.component.LayoutAndStructure",
              "urlPath": "",
              "componentId": "LayoutAndStructure",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.database",
          "name": "database",
          "displayName": "Database",
          "type": "file",
          "order": 4,
          "path": "start-here.database",
          "urlPath": "/start-here/database",
          "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
          "components": [
            {
              "id": "component-DatabaseConfiguration",
              "name": "DatabaseConfiguration",
              "displayName": "DatabaseConfiguration",
              "type": "component",
              "path": "database.component.DatabaseConfiguration",
              "urlPath": "",
              "componentId": "DatabaseConfiguration",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.next-steps",
          "name": "next-steps",
          "displayName": "Next Steps",
          "type": "file",
          "order": 5,
          "path": "start-here.next-steps",
          "urlPath": "/start-here/next-steps",
          "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
          "components": [],
          "sections": {},
          "include": true
        }
      ]
    },
    "start-here.tech-stack": {
      "id": "start-here.tech-stack",
      "name": "tech-stack",
      "displayName": "Tech Stack",
      "type": "file",
      "order": 1,
      "path": "start-here.tech-stack",
      "urlPath": "/start-here/tech-stack",
      "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
      "components": [
        {
          "id": "component-InitialConfiguration",
          "name": "InitialConfiguration",
          "displayName": "InitialConfiguration",
          "type": "component",
          "path": "tech-stack.component.InitialConfiguration",
          "urlPath": "",
          "componentId": "InitialConfiguration",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "tech-stack.component.InitialConfiguration": {
      "id": "component-InitialConfiguration",
      "name": "InitialConfiguration",
      "displayName": "InitialConfiguration",
      "type": "component",
      "path": "tech-stack.component.InitialConfiguration",
      "urlPath": "",
      "componentId": "InitialConfiguration",
      "include": true
    },
    "start-here.theme": {
      "id": "start-here.theme",
      "name": "theme",
      "displayName": "Theme",
      "type": "file",
      "order": 2,
      "path": "start-here.theme",
      "urlPath": "/start-here/theme",
      "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
      "components": [
        {
          "id": "component-ThemeConfiguration",
          "name": "ThemeConfiguration",
          "displayName": "ThemeConfiguration",
          "type": "component",
          "path": "theme.component.ThemeConfiguration",
          "urlPath": "",
          "componentId": "ThemeConfiguration",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "theme.component.ThemeConfiguration": {
      "id": "component-ThemeConfiguration",
      "name": "ThemeConfiguration",
      "displayName": "ThemeConfiguration",
      "type": "component",
      "path": "theme.component.ThemeConfiguration",
      "urlPath": "",
      "componentId": "ThemeConfiguration",
      "include": true
    },
    "start-here.layout-routes": {
      "id": "start-here.layout-routes",
      "name": "layout-routes",
      "displayName": "Layout & routes",
      "type": "file",
      "order": 3,
      "path": "start-here.layout-routes",
      "urlPath": "/start-here/layout-routes",
      "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
      "components": [
        {
          "id": "component-LayoutAndStructure",
          "name": "LayoutAndStructure",
          "displayName": "LayoutAndStructure",
          "type": "component",
          "path": "layout-routes.component.LayoutAndStructure",
          "urlPath": "",
          "componentId": "LayoutAndStructure",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "layout-routes.component.LayoutAndStructure": {
      "id": "component-LayoutAndStructure",
      "name": "LayoutAndStructure",
      "displayName": "LayoutAndStructure",
      "type": "component",
      "path": "layout-routes.component.LayoutAndStructure",
      "urlPath": "",
      "componentId": "LayoutAndStructure",
      "include": true
    },
    "start-here.database": {
      "id": "start-here.database",
      "name": "database",
      "displayName": "Database",
      "type": "file",
      "order": 4,
      "path": "start-here.database",
      "urlPath": "/start-here/database",
      "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
      "components": [
        {
          "id": "component-DatabaseConfiguration",
          "name": "DatabaseConfiguration",
          "displayName": "DatabaseConfiguration",
          "type": "component",
          "path": "database.component.DatabaseConfiguration",
          "urlPath": "",
          "componentId": "DatabaseConfiguration",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "database.component.DatabaseConfiguration": {
      "id": "component-DatabaseConfiguration",
      "name": "DatabaseConfiguration",
      "displayName": "DatabaseConfiguration",
      "type": "component",
      "path": "database.component.DatabaseConfiguration",
      "urlPath": "",
      "componentId": "DatabaseConfiguration",
      "include": true
    },
    "start-here.next-steps": {
      "id": "start-here.next-steps",
      "name": "next-steps",
      "displayName": "Next Steps",
      "type": "file",
      "order": 5,
      "path": "start-here.next-steps",
      "urlPath": "/start-here/next-steps",
      "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
      "components": [],
      "sections": {},
      "include": true
    }
  },
  "contentVersion": 39
}