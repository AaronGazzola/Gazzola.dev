{
  "root": {
    "id": "root",
    "name": "root",
    "displayName": "Root",
    "type": "directory",
    "path": "",
    "urlPath": "/",
    "include": true,
    "children": [
      {
        "id": "readme",
        "name": "readme",
        "displayName": "README",
        "type": "file",
        "order": 6,
        "path": "readme",
        "urlPath": "/readme",
        "content": "<!-- section-1 -->\n\n## Technologies Used\n\n<!-- section-2 -->\n\n<!-- section-3 -->\n\n<!-- section-4 -->\n\n<!-- section-5 -->\n\n<!-- section-6 -->\n\n## Project Structure\n\n<!-- component-AppStructure -->\n\n## Site Map\n\n<!-- component-SiteMap -->\n\n## Need Help?\n\nIf you run into any issues:\n\n1. Check that all environment variables are correctly set\n2. Verify that your database is running and accessible\n3. Ensure you're using Node.js version 18 or higher\n4. Try deleting \\`node_modules\\` and \\`.next\\` folders, then run \\`npm install\\` again\n\nFor more detailed documentation, refer to the individual technology documentation linked in the Technologies Used section.\n",
        "components": [
          {
            "id": "component-AppStructure",
            "name": "AppStructure",
            "displayName": "AppStructure",
            "type": "component",
            "path": "readme.component.AppStructure",
            "urlPath": "",
            "componentId": "AppStructure",
            "include": true
          },
          {
            "id": "component-SiteMap",
            "name": "SiteMap",
            "displayName": "SiteMap",
            "type": "component",
            "path": "readme.component.SiteMap",
            "urlPath": "",
            "componentId": "SiteMap",
            "include": true
          }
        ],
        "sections": {
          "section1": {
            "option1": {
              "content": "# Your Web Application\n\nA modern, full-stack web application built with the latest technologies to deliver a fast, secure, and scalable user experience.\n\n## What This Application Does\n\nThis web application provides a complete foundation for building dynamic web experiences. It includes user authentication, data management, and a responsive interface that works seamlessly across all devices.",
              "include": true
            }
          },
          "section2": {
            "option1": {
              "content": "**Next.js** - A powerful React framework that handles both the visual interface users see and the behind-the-scenes server operations, making your application fast and efficient.",
              "include": true
            },
            "option2": {
              "content": "**TailwindCSS** - A modern styling system that ensures your application looks professional and consistent across all pages.",
              "include": true
            },
            "option3": {
              "content": "**Shadcn/ui** - Pre-built, customizable interface components that provide a polished, professional appearance out of the box.",
              "include": true
            },
            "option4": {
              "content": "**TypeScript** - Adds safety checks to the code, catching errors before they reach users and making the application more reliable.",
              "include": true
            },
            "option5": {
              "content": "**Zustand** - Manages the application's data flow, ensuring information stays synchronized across different parts of the app.",
              "include": true
            },
            "option6": {
              "content": "**React Query** - Handles data fetching and caching efficiently, keeping the application fast and responsive.",
              "include": true
            },
            "option7": {
              "content": "**Supabase** - An all-in-one backend platform providing database storage, user authentication, and real-time data synchronization.",
              "include": true
            },
            "option8": {
              "content": "**NeonDB** - A modern PostgreSQL database that scales automatically and provides fast data access.",
              "include": true
            },
            "option9": {
              "content": "**Prisma** - A database toolkit that makes working with data safer and more efficient through type-safe queries.",
              "include": true
            },
            "option10": {
              "content": "**Better Auth** - A comprehensive authentication system supporting multiple sign-in methods (email/password, social logins, magic links).",
              "include": true
            },
            "option11": {
              "content": "**PostgreSQL** - A robust, industry-standard database system known for reliability and performance.",
              "include": true
            },
            "option12": {
              "content": "**Vercel** - A deployment platform optimized for Next.js applications, providing fast global delivery and automatic updates.",
              "include": true
            },
            "option13": {
              "content": "**Railway** - A cloud platform for deploying databases and backend services with simple configuration.",
              "include": true
            },
            "option14": {
              "content": "**Playwright** - Automated testing framework that verifies the application works correctly across different browsers.",
              "include": true
            },
            "option15": {
              "content": "**Cypress** - End-to-end testing tool that simulates real user interactions to ensure features work as expected.",
              "include": true
            },
            "option16": {
              "content": "**Resend** - Email delivery service for sending transactional emails (welcome messages, password resets, notifications).",
              "include": true
            },
            "option17": {
              "content": "**Stripe** - Payment processing platform for accepting credit card payments securely.",
              "include": true
            },
            "option18": {
              "content": "**PayPal** - Payment integration for accepting PayPal payments from customers worldwide.",
              "include": true
            },
            "option19": {
              "content": "**OpenRouter** - AI integration platform providing access to various language models for AI-powered features.",
              "include": true
            }
          },
          "section3": {
            "option1": {
              "content": "## Getting Started\n\n### Prerequisites\n\nBefore you begin, make sure you have these tools installed on your computer:\n\n- **Node.js** (version 18 or higher) - Download from [nodejs.org](https://nodejs.org)\n- **Git** - Download from [git-scm.com](https://git-scm.com)\n\nTo verify they're installed, open your terminal and run:\n\n```bash\nnode --version\ngit --version\n```\n\n### Installation Steps\n\n1. **Download the project files**\n\n   Open your terminal and navigate to where you want to store the project, then run:\n\n   ```bash\n   git clone <your-repository-url>\n   cd <your-project-name>\n   ```\n\n2. **Install dependencies**\n\n   This downloads all the necessary libraries and tools:\n\n   ```bash\n   npm install\n   ```",
              "include": true
            },
            "option2": {
              "content": "3. **Set up your database**\n\n   Install Prisma CLI globally:\n\n   ```bash\n   npm install -g prisma\n   ```\n\n   Initialize your database:\n\n   ```bash\n   npx prisma generate\n   npx prisma db push\n   ```",
              "include": true
            },
            "option3": {
              "content": "3. **Set up your Supabase project**\n\n   - Visit [supabase.com](https://supabase.com) and create a free account\n   - Create a new project\n   - Go to Project Settings > API to find your connection details",
              "include": true
            }
          },
          "section4": {
            "option1": {
              "content": "## Configuration\n\n### Environment Variables\n\nCreate a file named `.env.local` in the root of your project. This file stores sensitive configuration data:\n\n```env\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n```",
              "include": true
            },
            "option2": {
              "content": "Add your NeonDB connection string:\n\n```env\nDATABASE_URL=\"your-neondb-connection-string\"\n```\n\nGet your connection string from your NeonDB dashboard at [neon.tech](https://neon.tech).",
              "include": true
            },
            "option3": {
              "content": "Add your Supabase credentials:\n\n```env\nNEXT_PUBLIC_SUPABASE_URL=your-supabase-url\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key\nSUPABASE_SERVICE_ROLE_KEY=your-service-role-key\n```\n\nFind these values in your Supabase project's API settings.",
              "include": true
            },
            "option4": {
              "content": "Add your Better Auth configuration:\n\n```env\nBETTER_AUTH_SECRET=your-secret-key\nBETTER_AUTH_URL=http://localhost:3000\n```\n\nGenerate a secure secret key by running:\n\n```bash\nopenssl rand -base64 32\n```",
              "include": true
            },
            "option5": {
              "content": "Add your Stripe keys:\n\n```env\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your-publishable-key\nSTRIPE_SECRET_KEY=your-secret-key\nSTRIPE_WEBHOOK_SECRET=your-webhook-secret\n```\n\nGet these from your Stripe Dashboard at [stripe.com/dashboard](https://dashboard.stripe.com).",
              "include": true
            },
            "option6": {
              "content": "Add your PayPal credentials:\n\n```env\nNEXT_PUBLIC_PAYPAL_CLIENT_ID=your-client-id\nPAYPAL_CLIENT_SECRET=your-client-secret\n```\n\nGet these from your PayPal Developer Dashboard at [developer.paypal.com](https://developer.paypal.com).",
              "include": true
            },
            "option7": {
              "content": "Add your Resend API key:\n\n```env\nRESEND_API_KEY=your-resend-api-key\n```\n\nGet your API key from [resend.com/api-keys](https://resend.com/api-keys).",
              "include": true
            },
            "option8": {
              "content": "Add your OpenRouter API key:\n\n```env\nOPENROUTER_API_KEY=your-openrouter-api-key\n```\n\nGet your API key from [openrouter.ai/keys](https://openrouter.ai/keys).",
              "include": true
            }
          },
          "section5": {
            "option1": {
              "content": "## Development\n\n### Running the Application Locally\n\nStart the development server:\n\n```bash\nnpm run dev\n```\n\nOpen your web browser and visit [http://localhost:3000](http://localhost:3000)\n\nThe application will automatically reload when you make changes to the code.\n\n### Available Commands\n\n- `npm run dev` - Starts the development server\n- `npm run build` - Creates an optimized production build\n- `npm run start` - Runs the production build locally\n- `npm run lint` - Checks code for potential issues",
              "include": true
            },
            "option2": {
              "content": "- `npm run test` - Runs all tests\n- `npm run test:e2e` - Runs end-to-end tests with Playwright",
              "include": true
            },
            "option3": {
              "content": "- `npm run cypress:open` - Opens Cypress test runner\n- `npm run cypress:run` - Runs Cypress tests in headless mode",
              "include": true
            },
            "option4": {
              "content": "- `npx prisma studio` - Opens a visual database editor\n- `npx prisma migrate dev` - Creates and applies database migrations\n- `npx prisma generate` - Generates Prisma client types",
              "include": true
            }
          },
          "section6": {
            "option1": {
              "content": "## Deployment\n\n### Deploying to Vercel\n\nVercel is the recommended platform for deploying Next.js applications:\n\n1. **Create a Vercel account**\n\n   Visit [vercel.com](https://vercel.com) and sign up with your GitHub account.\n\n2. **Import your project**\n\n   - Click \"New Project\" in your Vercel dashboard\n   - Import your GitHub repository\n   - Vercel will automatically detect Next.js settings\n\n3. **Add environment variables**\n\n   In your project settings, add all the environment variables from your `.env.local` file.\n\n4. **Deploy**\n\n   Click \"Deploy\" and Vercel will build and publish your application.\n\nYour application will be live at `https://your-project-name.vercel.app`\n\nEvery time you push code to your main branch, Vercel will automatically deploy the updates.",
              "include": true
            },
            "option2": {
              "content": "### Deploying Your Database to Railway\n\nIf you're using NeonDB or need to host PostgreSQL:\n\n1. **Create a Railway account**\n\n   Visit [railway.app](https://railway.app) and sign up.\n\n2. **Create a new PostgreSQL database**\n\n   - Click \"New Project\"\n   - Select \"Provision PostgreSQL\"\n   - Copy the connection string from the \"Connect\" tab\n\n3. **Update your environment variables**\n\n   Add the Railway database connection string to your Vercel environment variables.\n\n4. **Run migrations**\n\n   After deployment, run your database migrations:\n\n   ```bash\n   npx prisma migrate deploy\n   ```",
              "include": true
            }
          }
        },
        "include": true
      },
      {
        "id": "robots",
        "name": "robots",
        "displayName": "ROBOTS",
        "type": "file",
        "order": 7,
        "path": "robots",
        "urlPath": "/robots",
        "content": "",
        "components": [],
        "sections": {},
        "include": true
      },
      {
        "id": "claude",
        "name": "claude",
        "displayName": "CLAUDE",
        "type": "file",
        "order": 8,
        "path": "claude",
        "urlPath": "/claude",
        "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Core Technologies\n\n<!-- section-1 -->\n\n# General rules:\n\n- Don't include any comments in any files.\n- All errors should be thrown - no \"fallback\" functionality\n- Import \"cn\" from \"@/lib/utils\" to concatinate classes.\n\n# File Organization and Naming Conventions\n\n<!-- section-2 -->\n\n# Hook, action, store and type patterns\n\n<!-- section-3 -->\n\n## Example of file patterns - [\\`docs/utils.md\\`](docs/utils.md)\n\nFollow the examples outlined in [\\`docs/utils.md\\`](docs/utils.md) when working on hook, action, store or type files. The file also contains the \\`prisma-rls.ts\\` and \\`action.utils.ts\\` files for reference.\n\n# Testing\n\n<!-- section-4 -->\n\n# Console.logging\n\nAll logging should be performed using the \\`conditionalLog\\` function exported from \\`lib/log.utils.ts\\`\nThe \\`NEXT_PUBLIC_LOG_LABELS\\` variable in \\`.env.local\\` stores a comma separated string of log labels. Logs are returned if \\`NEXT_PUBLIC_LOG_LABELS=\"all\"\\`, or if \\`NEXT_PUBLIC_LOG_LABELS\\` includes the label arg in \\`conditionalLog\\`.\n",
        "components": [],
        "sections": {
          "section1": {
            "option1": {
              "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
              "include": true
            },
            "option2": {
              "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
              "include": true
            },
            "option3": {
              "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
              "include": true
            },
            "option4": {
              "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
              "include": true
            },
            "option5": {
              "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
              "include": true
            },
            "option6": {
              "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
              "include": true
            },
            "option7": {
              "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
              "include": true
            },
            "option8": {
              "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
              "include": true
            },
            "option9": {
              "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
              "include": true
            },
            "option10": {
              "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
              "include": true
            },
            "option11": {
              "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
              "include": true
            },
            "option12": {
              "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
              "include": true
            },
            "option13": {
              "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
              "include": true
            },
            "option14": {
              "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
              "include": true
            },
            "option15": {
              "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
              "include": true
            },
            "option16": {
              "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
              "include": true
            },
            "option17": {
              "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
              "include": true
            }
          },
          "section2": {
            "option1": {
              "content": "Types and store files alongside ancestor files. Actions and hooks files alongside descendent files.\n\n```txt\napp/\n├── layout.tsx\n├── layout.providers.tsx\n├── layout.types.ts\n├── layout.stores.ts ◄─── useAppStore\n└── (dashboard)/\n    ├── layout.tsx\n    ├── layout.types.tsx\n    ├── layout.stores.tsx ◄─── useDashboardStore\n    ├── page.tsx              ─┐\n    ├── page.hooks.tsx         ├────► useAppStore\n    ├── Component.tsx          ├────► useDashboardStore\n    ├── Component.hooks.tsx   ─┘\n    ├── page.actions.ts\n    └── Component.actions.ts\n\n    key:\n    ◄─── = defined\n    ───► = imported\n```",
              "include": true
            },
            "option2": {
              "content": "<!-- component-AppStructure -->",
              "include": true
            }
          },
          "section3": {
            "option1": {
              "content": "**Client-side only (No database)**\n\nComponent <-> hook <-> store\n\n- React Query hooks fetch data from external APIs or manage client-side state.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.",
              "include": true
            },
            "option2": {
              "content": "**NeonDB + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
              "include": true
            },
            "option3": {
              "content": "**Supabase + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
              "include": true
            },
            "option4": {
              "content": "**Supabase only (Supabase Auth)**\n\nDB <-> Supabase Client <-> hook <-> store\n\n- Supabase client queries are called directly in react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `@/integrations/supabase/types`.",
              "include": true
            }
          },
          "section4": {
            "option1": {
              "content": "All tests should be performed with Playwright and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
              "include": true
            },
            "option2": {
              "content": "All tests should be performed with Playwright or Cypress and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
              "include": true
            }
          }
        },
        "include": true
      },
      {
        "id": "code-files",
        "name": "code-files",
        "displayName": "Code files",
        "type": "directory",
        "path": "code-files",
        "urlPath": "/code-files",
        "include": true,
        "children": []
      },
      {
        "id": "docs",
        "name": "docs",
        "displayName": "docs",
        "type": "directory",
        "path": "docs",
        "urlPath": "/docs",
        "include": true,
        "children": [
          {
            "id": "docs.deployment-instructions",
            "name": "deployment-instructions",
            "displayName": "Deployment instructions",
            "type": "file",
            "order": 9,
            "path": "docs.deployment-instructions",
            "urlPath": "/docs/deployment-instructions",
            "content": "",
            "components": [],
            "sections": {},
            "include": true
          },
          {
            "id": "docs.util",
            "name": "util",
            "displayName": "util",
            "type": "file",
            "order": 10,
            "path": "docs.util",
            "urlPath": "/docs/util",
            "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
            "components": [],
            "sections": {
              "section1": {
                "option1": {
                  "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
                  "include": true
                },
                "option2": {
                  "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
                  "include": true
                }
              },
              "section2": {
                "option1": {
                  "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
                  "include": true
                }
              },
              "section3": {
                "option1": {
                  "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
                  "include": true
                },
                "option2": {
                  "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                  "include": true
                },
                "option3": {
                  "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                  "include": true
                },
                "option4": {
                  "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                  "include": true
                }
              },
              "section4": {
                "option1": {
                  "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
                  "include": true
                },
                "option2": {
                  "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
                  "include": true
                },
                "option3": {
                  "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
                  "include": true
                }
              },
              "section5": {
                "option1": {
                  "content": "**No utility files needed for client-side only applications.**",
                  "include": true
                },
                "option2": {
                  "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                  "include": true
                },
                "option3": {
                  "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                  "include": true
                }
              }
            },
            "include": true
          }
        ]
      },
      {
        "id": "start-here",
        "name": "start-here",
        "displayName": "Start here",
        "type": "directory",
        "path": "start-here",
        "urlPath": "/start-here",
        "include": true,
        "children": [
          {
            "id": "start-here.tech-stack",
            "name": "tech-stack",
            "displayName": "Tech Stack",
            "type": "file",
            "order": 1,
            "path": "start-here.tech-stack",
            "urlPath": "/start-here/tech-stack",
            "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
            "components": [
              {
                "id": "component-InitialConfiguration",
                "name": "InitialConfiguration",
                "displayName": "InitialConfiguration",
                "type": "component",
                "path": "tech-stack.component.InitialConfiguration",
                "urlPath": "",
                "componentId": "InitialConfiguration",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.theme",
            "name": "theme",
            "displayName": "Theme",
            "type": "file",
            "order": 2,
            "path": "start-here.theme",
            "urlPath": "/start-here/theme",
            "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
            "components": [
              {
                "id": "component-ThemeConfiguration",
                "name": "ThemeConfiguration",
                "displayName": "ThemeConfiguration",
                "type": "component",
                "path": "theme.component.ThemeConfiguration",
                "urlPath": "",
                "componentId": "ThemeConfiguration",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.layout-routes",
            "name": "layout-routes",
            "displayName": "Layout & routes",
            "type": "file",
            "order": 3,
            "path": "start-here.layout-routes",
            "urlPath": "/start-here/layout-routes",
            "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
            "components": [
              {
                "id": "component-LayoutAndStructure",
                "name": "LayoutAndStructure",
                "displayName": "LayoutAndStructure",
                "type": "component",
                "path": "layout-routes.component.LayoutAndStructure",
                "urlPath": "",
                "componentId": "LayoutAndStructure",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.database",
            "name": "database",
            "displayName": "Database",
            "type": "file",
            "order": 4,
            "path": "start-here.database",
            "urlPath": "/start-here/database",
            "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
            "components": [
              {
                "id": "component-DatabaseConfiguration",
                "name": "DatabaseConfiguration",
                "displayName": "DatabaseConfiguration",
                "type": "component",
                "path": "database.component.DatabaseConfiguration",
                "urlPath": "",
                "componentId": "DatabaseConfiguration",
                "include": true
              }
            ],
            "sections": {},
            "include": true
          },
          {
            "id": "start-here.next-steps",
            "name": "next-steps",
            "displayName": "Next Steps",
            "type": "file",
            "order": 5,
            "path": "start-here.next-steps",
            "urlPath": "/start-here/next-steps",
            "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
            "components": [],
            "sections": {},
            "include": true
          }
        ]
      }
    ]
  },
  "flatIndex": {
    "": {
      "id": "root",
      "name": "root",
      "displayName": "Root",
      "type": "directory",
      "path": "",
      "urlPath": "/",
      "include": true,
      "children": [
        {
          "id": "readme",
          "name": "readme",
          "displayName": "README",
          "type": "file",
          "order": 6,
          "path": "readme",
          "urlPath": "/readme",
          "content": "<!-- section-1 -->\n\n## Technologies Used\n\n<!-- section-2 -->\n\n<!-- section-3 -->\n\n<!-- section-4 -->\n\n<!-- section-5 -->\n\n<!-- section-6 -->\n\n## Project Structure\n\n<!-- component-AppStructure -->\n\n## Site Map\n\n<!-- component-SiteMap -->\n\n## Need Help?\n\nIf you run into any issues:\n\n1. Check that all environment variables are correctly set\n2. Verify that your database is running and accessible\n3. Ensure you're using Node.js version 18 or higher\n4. Try deleting \\`node_modules\\` and \\`.next\\` folders, then run \\`npm install\\` again\n\nFor more detailed documentation, refer to the individual technology documentation linked in the Technologies Used section.\n",
          "components": [
            {
              "id": "component-AppStructure",
              "name": "AppStructure",
              "displayName": "AppStructure",
              "type": "component",
              "path": "readme.component.AppStructure",
              "urlPath": "",
              "componentId": "AppStructure",
              "include": true
            },
            {
              "id": "component-SiteMap",
              "name": "SiteMap",
              "displayName": "SiteMap",
              "type": "component",
              "path": "readme.component.SiteMap",
              "urlPath": "",
              "componentId": "SiteMap",
              "include": true
            }
          ],
          "sections": {
            "section1": {
              "option1": {
                "content": "# Your Web Application\n\nA modern, full-stack web application built with the latest technologies to deliver a fast, secure, and scalable user experience.\n\n## What This Application Does\n\nThis web application provides a complete foundation for building dynamic web experiences. It includes user authentication, data management, and a responsive interface that works seamlessly across all devices.",
                "include": true
              }
            },
            "section2": {
              "option1": {
                "content": "**Next.js** - A powerful React framework that handles both the visual interface users see and the behind-the-scenes server operations, making your application fast and efficient.",
                "include": true
              },
              "option2": {
                "content": "**TailwindCSS** - A modern styling system that ensures your application looks professional and consistent across all pages.",
                "include": true
              },
              "option3": {
                "content": "**Shadcn/ui** - Pre-built, customizable interface components that provide a polished, professional appearance out of the box.",
                "include": true
              },
              "option4": {
                "content": "**TypeScript** - Adds safety checks to the code, catching errors before they reach users and making the application more reliable.",
                "include": true
              },
              "option5": {
                "content": "**Zustand** - Manages the application's data flow, ensuring information stays synchronized across different parts of the app.",
                "include": true
              },
              "option6": {
                "content": "**React Query** - Handles data fetching and caching efficiently, keeping the application fast and responsive.",
                "include": true
              },
              "option7": {
                "content": "**Supabase** - An all-in-one backend platform providing database storage, user authentication, and real-time data synchronization.",
                "include": true
              },
              "option8": {
                "content": "**NeonDB** - A modern PostgreSQL database that scales automatically and provides fast data access.",
                "include": true
              },
              "option9": {
                "content": "**Prisma** - A database toolkit that makes working with data safer and more efficient through type-safe queries.",
                "include": true
              },
              "option10": {
                "content": "**Better Auth** - A comprehensive authentication system supporting multiple sign-in methods (email/password, social logins, magic links).",
                "include": true
              },
              "option11": {
                "content": "**PostgreSQL** - A robust, industry-standard database system known for reliability and performance.",
                "include": true
              },
              "option12": {
                "content": "**Vercel** - A deployment platform optimized for Next.js applications, providing fast global delivery and automatic updates.",
                "include": true
              },
              "option13": {
                "content": "**Railway** - A cloud platform for deploying databases and backend services with simple configuration.",
                "include": true
              },
              "option14": {
                "content": "**Playwright** - Automated testing framework that verifies the application works correctly across different browsers.",
                "include": true
              },
              "option15": {
                "content": "**Cypress** - End-to-end testing tool that simulates real user interactions to ensure features work as expected.",
                "include": true
              },
              "option16": {
                "content": "**Resend** - Email delivery service for sending transactional emails (welcome messages, password resets, notifications).",
                "include": true
              },
              "option17": {
                "content": "**Stripe** - Payment processing platform for accepting credit card payments securely.",
                "include": true
              },
              "option18": {
                "content": "**PayPal** - Payment integration for accepting PayPal payments from customers worldwide.",
                "include": true
              },
              "option19": {
                "content": "**OpenRouter** - AI integration platform providing access to various language models for AI-powered features.",
                "include": true
              }
            },
            "section3": {
              "option1": {
                "content": "## Getting Started\n\n### Prerequisites\n\nBefore you begin, make sure you have these tools installed on your computer:\n\n- **Node.js** (version 18 or higher) - Download from [nodejs.org](https://nodejs.org)\n- **Git** - Download from [git-scm.com](https://git-scm.com)\n\nTo verify they're installed, open your terminal and run:\n\n```bash\nnode --version\ngit --version\n```\n\n### Installation Steps\n\n1. **Download the project files**\n\n   Open your terminal and navigate to where you want to store the project, then run:\n\n   ```bash\n   git clone <your-repository-url>\n   cd <your-project-name>\n   ```\n\n2. **Install dependencies**\n\n   This downloads all the necessary libraries and tools:\n\n   ```bash\n   npm install\n   ```",
                "include": true
              },
              "option2": {
                "content": "3. **Set up your database**\n\n   Install Prisma CLI globally:\n\n   ```bash\n   npm install -g prisma\n   ```\n\n   Initialize your database:\n\n   ```bash\n   npx prisma generate\n   npx prisma db push\n   ```",
                "include": true
              },
              "option3": {
                "content": "3. **Set up your Supabase project**\n\n   - Visit [supabase.com](https://supabase.com) and create a free account\n   - Create a new project\n   - Go to Project Settings > API to find your connection details",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "## Configuration\n\n### Environment Variables\n\nCreate a file named `.env.local` in the root of your project. This file stores sensitive configuration data:\n\n```env\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n```",
                "include": true
              },
              "option2": {
                "content": "Add your NeonDB connection string:\n\n```env\nDATABASE_URL=\"your-neondb-connection-string\"\n```\n\nGet your connection string from your NeonDB dashboard at [neon.tech](https://neon.tech).",
                "include": true
              },
              "option3": {
                "content": "Add your Supabase credentials:\n\n```env\nNEXT_PUBLIC_SUPABASE_URL=your-supabase-url\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key\nSUPABASE_SERVICE_ROLE_KEY=your-service-role-key\n```\n\nFind these values in your Supabase project's API settings.",
                "include": true
              },
              "option4": {
                "content": "Add your Better Auth configuration:\n\n```env\nBETTER_AUTH_SECRET=your-secret-key\nBETTER_AUTH_URL=http://localhost:3000\n```\n\nGenerate a secure secret key by running:\n\n```bash\nopenssl rand -base64 32\n```",
                "include": true
              },
              "option5": {
                "content": "Add your Stripe keys:\n\n```env\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your-publishable-key\nSTRIPE_SECRET_KEY=your-secret-key\nSTRIPE_WEBHOOK_SECRET=your-webhook-secret\n```\n\nGet these from your Stripe Dashboard at [stripe.com/dashboard](https://dashboard.stripe.com).",
                "include": true
              },
              "option6": {
                "content": "Add your PayPal credentials:\n\n```env\nNEXT_PUBLIC_PAYPAL_CLIENT_ID=your-client-id\nPAYPAL_CLIENT_SECRET=your-client-secret\n```\n\nGet these from your PayPal Developer Dashboard at [developer.paypal.com](https://developer.paypal.com).",
                "include": true
              },
              "option7": {
                "content": "Add your Resend API key:\n\n```env\nRESEND_API_KEY=your-resend-api-key\n```\n\nGet your API key from [resend.com/api-keys](https://resend.com/api-keys).",
                "include": true
              },
              "option8": {
                "content": "Add your OpenRouter API key:\n\n```env\nOPENROUTER_API_KEY=your-openrouter-api-key\n```\n\nGet your API key from [openrouter.ai/keys](https://openrouter.ai/keys).",
                "include": true
              }
            },
            "section5": {
              "option1": {
                "content": "## Development\n\n### Running the Application Locally\n\nStart the development server:\n\n```bash\nnpm run dev\n```\n\nOpen your web browser and visit [http://localhost:3000](http://localhost:3000)\n\nThe application will automatically reload when you make changes to the code.\n\n### Available Commands\n\n- `npm run dev` - Starts the development server\n- `npm run build` - Creates an optimized production build\n- `npm run start` - Runs the production build locally\n- `npm run lint` - Checks code for potential issues",
                "include": true
              },
              "option2": {
                "content": "- `npm run test` - Runs all tests\n- `npm run test:e2e` - Runs end-to-end tests with Playwright",
                "include": true
              },
              "option3": {
                "content": "- `npm run cypress:open` - Opens Cypress test runner\n- `npm run cypress:run` - Runs Cypress tests in headless mode",
                "include": true
              },
              "option4": {
                "content": "- `npx prisma studio` - Opens a visual database editor\n- `npx prisma migrate dev` - Creates and applies database migrations\n- `npx prisma generate` - Generates Prisma client types",
                "include": true
              }
            },
            "section6": {
              "option1": {
                "content": "## Deployment\n\n### Deploying to Vercel\n\nVercel is the recommended platform for deploying Next.js applications:\n\n1. **Create a Vercel account**\n\n   Visit [vercel.com](https://vercel.com) and sign up with your GitHub account.\n\n2. **Import your project**\n\n   - Click \"New Project\" in your Vercel dashboard\n   - Import your GitHub repository\n   - Vercel will automatically detect Next.js settings\n\n3. **Add environment variables**\n\n   In your project settings, add all the environment variables from your `.env.local` file.\n\n4. **Deploy**\n\n   Click \"Deploy\" and Vercel will build and publish your application.\n\nYour application will be live at `https://your-project-name.vercel.app`\n\nEvery time you push code to your main branch, Vercel will automatically deploy the updates.",
                "include": true
              },
              "option2": {
                "content": "### Deploying Your Database to Railway\n\nIf you're using NeonDB or need to host PostgreSQL:\n\n1. **Create a Railway account**\n\n   Visit [railway.app](https://railway.app) and sign up.\n\n2. **Create a new PostgreSQL database**\n\n   - Click \"New Project\"\n   - Select \"Provision PostgreSQL\"\n   - Copy the connection string from the \"Connect\" tab\n\n3. **Update your environment variables**\n\n   Add the Railway database connection string to your Vercel environment variables.\n\n4. **Run migrations**\n\n   After deployment, run your database migrations:\n\n   ```bash\n   npx prisma migrate deploy\n   ```",
                "include": true
              }
            }
          },
          "include": true
        },
        {
          "id": "robots",
          "name": "robots",
          "displayName": "ROBOTS",
          "type": "file",
          "order": 7,
          "path": "robots",
          "urlPath": "/robots",
          "content": "",
          "components": [],
          "sections": {},
          "include": true
        },
        {
          "id": "claude",
          "name": "claude",
          "displayName": "CLAUDE",
          "type": "file",
          "order": 8,
          "path": "claude",
          "urlPath": "/claude",
          "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Core Technologies\n\n<!-- section-1 -->\n\n# General rules:\n\n- Don't include any comments in any files.\n- All errors should be thrown - no \"fallback\" functionality\n- Import \"cn\" from \"@/lib/utils\" to concatinate classes.\n\n# File Organization and Naming Conventions\n\n<!-- section-2 -->\n\n# Hook, action, store and type patterns\n\n<!-- section-3 -->\n\n## Example of file patterns - [\\`docs/utils.md\\`](docs/utils.md)\n\nFollow the examples outlined in [\\`docs/utils.md\\`](docs/utils.md) when working on hook, action, store or type files. The file also contains the \\`prisma-rls.ts\\` and \\`action.utils.ts\\` files for reference.\n\n# Testing\n\n<!-- section-4 -->\n\n# Console.logging\n\nAll logging should be performed using the \\`conditionalLog\\` function exported from \\`lib/log.utils.ts\\`\nThe \\`NEXT_PUBLIC_LOG_LABELS\\` variable in \\`.env.local\\` stores a comma separated string of log labels. Logs are returned if \\`NEXT_PUBLIC_LOG_LABELS=\"all\"\\`, or if \\`NEXT_PUBLIC_LOG_LABELS\\` includes the label arg in \\`conditionalLog\\`.\n",
          "components": [],
          "sections": {
            "section1": {
              "option1": {
                "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
                "include": true
              },
              "option2": {
                "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
                "include": true
              },
              "option3": {
                "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
                "include": true
              },
              "option4": {
                "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
                "include": true
              },
              "option5": {
                "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
                "include": true
              },
              "option6": {
                "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
                "include": true
              },
              "option7": {
                "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
                "include": true
              },
              "option8": {
                "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
                "include": true
              },
              "option9": {
                "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
                "include": true
              },
              "option10": {
                "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
                "include": true
              },
              "option11": {
                "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
                "include": true
              },
              "option12": {
                "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
                "include": true
              },
              "option13": {
                "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
                "include": true
              },
              "option14": {
                "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
                "include": true
              },
              "option15": {
                "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
                "include": true
              },
              "option16": {
                "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
                "include": true
              },
              "option17": {
                "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
                "include": true
              }
            },
            "section2": {
              "option1": {
                "content": "Types and store files alongside ancestor files. Actions and hooks files alongside descendent files.\n\n```txt\napp/\n├── layout.tsx\n├── layout.providers.tsx\n├── layout.types.ts\n├── layout.stores.ts ◄─── useAppStore\n└── (dashboard)/\n    ├── layout.tsx\n    ├── layout.types.tsx\n    ├── layout.stores.tsx ◄─── useDashboardStore\n    ├── page.tsx              ─┐\n    ├── page.hooks.tsx         ├────► useAppStore\n    ├── Component.tsx          ├────► useDashboardStore\n    ├── Component.hooks.tsx   ─┘\n    ├── page.actions.ts\n    └── Component.actions.ts\n\n    key:\n    ◄─── = defined\n    ───► = imported\n```",
                "include": true
              },
              "option2": {
                "content": "<!-- component-AppStructure -->",
                "include": true
              }
            },
            "section3": {
              "option1": {
                "content": "**Client-side only (No database)**\n\nComponent <-> hook <-> store\n\n- React Query hooks fetch data from external APIs or manage client-side state.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.",
                "include": true
              },
              "option2": {
                "content": "**NeonDB + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
                "include": true
              },
              "option3": {
                "content": "**Supabase + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
                "include": true
              },
              "option4": {
                "content": "**Supabase only (Supabase Auth)**\n\nDB <-> Supabase Client <-> hook <-> store\n\n- Supabase client queries are called directly in react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `@/integrations/supabase/types`.",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "All tests should be performed with Playwright and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
                "include": true
              },
              "option2": {
                "content": "All tests should be performed with Playwright or Cypress and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
                "include": true
              }
            }
          },
          "include": true
        },
        {
          "id": "code-files",
          "name": "code-files",
          "displayName": "Code files",
          "type": "directory",
          "path": "code-files",
          "urlPath": "/code-files",
          "include": true,
          "children": []
        },
        {
          "id": "docs",
          "name": "docs",
          "displayName": "docs",
          "type": "directory",
          "path": "docs",
          "urlPath": "/docs",
          "include": true,
          "children": [
            {
              "id": "docs.deployment-instructions",
              "name": "deployment-instructions",
              "displayName": "Deployment instructions",
              "type": "file",
              "order": 9,
              "path": "docs.deployment-instructions",
              "urlPath": "/docs/deployment-instructions",
              "content": "",
              "components": [],
              "sections": {},
              "include": true
            },
            {
              "id": "docs.util",
              "name": "util",
              "displayName": "util",
              "type": "file",
              "order": 10,
              "path": "docs.util",
              "urlPath": "/docs/util",
              "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
              "components": [],
              "sections": {
                "section1": {
                  "option1": {
                    "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
                    "include": true
                  },
                  "option2": {
                    "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
                    "include": true
                  }
                },
                "section2": {
                  "option1": {
                    "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
                    "include": true
                  }
                },
                "section3": {
                  "option1": {
                    "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
                    "include": true
                  },
                  "option2": {
                    "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                    "include": true
                  },
                  "option3": {
                    "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                    "include": true
                  },
                  "option4": {
                    "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                    "include": true
                  }
                },
                "section4": {
                  "option1": {
                    "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
                    "include": true
                  },
                  "option2": {
                    "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
                    "include": true
                  },
                  "option3": {
                    "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
                    "include": true
                  }
                },
                "section5": {
                  "option1": {
                    "content": "**No utility files needed for client-side only applications.**",
                    "include": true
                  },
                  "option2": {
                    "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                    "include": true
                  },
                  "option3": {
                    "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                    "include": true
                  }
                }
              },
              "include": true
            }
          ]
        },
        {
          "id": "start-here",
          "name": "start-here",
          "displayName": "Start here",
          "type": "directory",
          "path": "start-here",
          "urlPath": "/start-here",
          "include": true,
          "children": [
            {
              "id": "start-here.tech-stack",
              "name": "tech-stack",
              "displayName": "Tech Stack",
              "type": "file",
              "order": 1,
              "path": "start-here.tech-stack",
              "urlPath": "/start-here/tech-stack",
              "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
              "components": [
                {
                  "id": "component-InitialConfiguration",
                  "name": "InitialConfiguration",
                  "displayName": "InitialConfiguration",
                  "type": "component",
                  "path": "tech-stack.component.InitialConfiguration",
                  "urlPath": "",
                  "componentId": "InitialConfiguration",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.theme",
              "name": "theme",
              "displayName": "Theme",
              "type": "file",
              "order": 2,
              "path": "start-here.theme",
              "urlPath": "/start-here/theme",
              "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
              "components": [
                {
                  "id": "component-ThemeConfiguration",
                  "name": "ThemeConfiguration",
                  "displayName": "ThemeConfiguration",
                  "type": "component",
                  "path": "theme.component.ThemeConfiguration",
                  "urlPath": "",
                  "componentId": "ThemeConfiguration",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.layout-routes",
              "name": "layout-routes",
              "displayName": "Layout & routes",
              "type": "file",
              "order": 3,
              "path": "start-here.layout-routes",
              "urlPath": "/start-here/layout-routes",
              "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
              "components": [
                {
                  "id": "component-LayoutAndStructure",
                  "name": "LayoutAndStructure",
                  "displayName": "LayoutAndStructure",
                  "type": "component",
                  "path": "layout-routes.component.LayoutAndStructure",
                  "urlPath": "",
                  "componentId": "LayoutAndStructure",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.database",
              "name": "database",
              "displayName": "Database",
              "type": "file",
              "order": 4,
              "path": "start-here.database",
              "urlPath": "/start-here/database",
              "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
              "components": [
                {
                  "id": "component-DatabaseConfiguration",
                  "name": "DatabaseConfiguration",
                  "displayName": "DatabaseConfiguration",
                  "type": "component",
                  "path": "database.component.DatabaseConfiguration",
                  "urlPath": "",
                  "componentId": "DatabaseConfiguration",
                  "include": true
                }
              ],
              "sections": {},
              "include": true
            },
            {
              "id": "start-here.next-steps",
              "name": "next-steps",
              "displayName": "Next Steps",
              "type": "file",
              "order": 5,
              "path": "start-here.next-steps",
              "urlPath": "/start-here/next-steps",
              "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
              "components": [],
              "sections": {},
              "include": true
            }
          ]
        }
      ]
    },
    "readme": {
      "id": "readme",
      "name": "readme",
      "displayName": "README",
      "type": "file",
      "order": 6,
      "path": "readme",
      "urlPath": "/readme",
      "content": "<!-- section-1 -->\n\n## Technologies Used\n\n<!-- section-2 -->\n\n<!-- section-3 -->\n\n<!-- section-4 -->\n\n<!-- section-5 -->\n\n<!-- section-6 -->\n\n## Project Structure\n\n<!-- component-AppStructure -->\n\n## Site Map\n\n<!-- component-SiteMap -->\n\n## Need Help?\n\nIf you run into any issues:\n\n1. Check that all environment variables are correctly set\n2. Verify that your database is running and accessible\n3. Ensure you're using Node.js version 18 or higher\n4. Try deleting \\`node_modules\\` and \\`.next\\` folders, then run \\`npm install\\` again\n\nFor more detailed documentation, refer to the individual technology documentation linked in the Technologies Used section.\n",
      "components": [
        {
          "id": "component-AppStructure",
          "name": "AppStructure",
          "displayName": "AppStructure",
          "type": "component",
          "path": "readme.component.AppStructure",
          "urlPath": "",
          "componentId": "AppStructure",
          "include": true
        },
        {
          "id": "component-SiteMap",
          "name": "SiteMap",
          "displayName": "SiteMap",
          "type": "component",
          "path": "readme.component.SiteMap",
          "urlPath": "",
          "componentId": "SiteMap",
          "include": true
        }
      ],
      "sections": {
        "section1": {
          "option1": {
            "content": "# Your Web Application\n\nA modern, full-stack web application built with the latest technologies to deliver a fast, secure, and scalable user experience.\n\n## What This Application Does\n\nThis web application provides a complete foundation for building dynamic web experiences. It includes user authentication, data management, and a responsive interface that works seamlessly across all devices.",
            "include": true
          }
        },
        "section2": {
          "option1": {
            "content": "**Next.js** - A powerful React framework that handles both the visual interface users see and the behind-the-scenes server operations, making your application fast and efficient.",
            "include": true
          },
          "option2": {
            "content": "**TailwindCSS** - A modern styling system that ensures your application looks professional and consistent across all pages.",
            "include": true
          },
          "option3": {
            "content": "**Shadcn/ui** - Pre-built, customizable interface components that provide a polished, professional appearance out of the box.",
            "include": true
          },
          "option4": {
            "content": "**TypeScript** - Adds safety checks to the code, catching errors before they reach users and making the application more reliable.",
            "include": true
          },
          "option5": {
            "content": "**Zustand** - Manages the application's data flow, ensuring information stays synchronized across different parts of the app.",
            "include": true
          },
          "option6": {
            "content": "**React Query** - Handles data fetching and caching efficiently, keeping the application fast and responsive.",
            "include": true
          },
          "option7": {
            "content": "**Supabase** - An all-in-one backend platform providing database storage, user authentication, and real-time data synchronization.",
            "include": true
          },
          "option8": {
            "content": "**NeonDB** - A modern PostgreSQL database that scales automatically and provides fast data access.",
            "include": true
          },
          "option9": {
            "content": "**Prisma** - A database toolkit that makes working with data safer and more efficient through type-safe queries.",
            "include": true
          },
          "option10": {
            "content": "**Better Auth** - A comprehensive authentication system supporting multiple sign-in methods (email/password, social logins, magic links).",
            "include": true
          },
          "option11": {
            "content": "**PostgreSQL** - A robust, industry-standard database system known for reliability and performance.",
            "include": true
          },
          "option12": {
            "content": "**Vercel** - A deployment platform optimized for Next.js applications, providing fast global delivery and automatic updates.",
            "include": true
          },
          "option13": {
            "content": "**Railway** - A cloud platform for deploying databases and backend services with simple configuration.",
            "include": true
          },
          "option14": {
            "content": "**Playwright** - Automated testing framework that verifies the application works correctly across different browsers.",
            "include": true
          },
          "option15": {
            "content": "**Cypress** - End-to-end testing tool that simulates real user interactions to ensure features work as expected.",
            "include": true
          },
          "option16": {
            "content": "**Resend** - Email delivery service for sending transactional emails (welcome messages, password resets, notifications).",
            "include": true
          },
          "option17": {
            "content": "**Stripe** - Payment processing platform for accepting credit card payments securely.",
            "include": true
          },
          "option18": {
            "content": "**PayPal** - Payment integration for accepting PayPal payments from customers worldwide.",
            "include": true
          },
          "option19": {
            "content": "**OpenRouter** - AI integration platform providing access to various language models for AI-powered features.",
            "include": true
          }
        },
        "section3": {
          "option1": {
            "content": "## Getting Started\n\n### Prerequisites\n\nBefore you begin, make sure you have these tools installed on your computer:\n\n- **Node.js** (version 18 or higher) - Download from [nodejs.org](https://nodejs.org)\n- **Git** - Download from [git-scm.com](https://git-scm.com)\n\nTo verify they're installed, open your terminal and run:\n\n```bash\nnode --version\ngit --version\n```\n\n### Installation Steps\n\n1. **Download the project files**\n\n   Open your terminal and navigate to where you want to store the project, then run:\n\n   ```bash\n   git clone <your-repository-url>\n   cd <your-project-name>\n   ```\n\n2. **Install dependencies**\n\n   This downloads all the necessary libraries and tools:\n\n   ```bash\n   npm install\n   ```",
            "include": true
          },
          "option2": {
            "content": "3. **Set up your database**\n\n   Install Prisma CLI globally:\n\n   ```bash\n   npm install -g prisma\n   ```\n\n   Initialize your database:\n\n   ```bash\n   npx prisma generate\n   npx prisma db push\n   ```",
            "include": true
          },
          "option3": {
            "content": "3. **Set up your Supabase project**\n\n   - Visit [supabase.com](https://supabase.com) and create a free account\n   - Create a new project\n   - Go to Project Settings > API to find your connection details",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "## Configuration\n\n### Environment Variables\n\nCreate a file named `.env.local` in the root of your project. This file stores sensitive configuration data:\n\n```env\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n```",
            "include": true
          },
          "option2": {
            "content": "Add your NeonDB connection string:\n\n```env\nDATABASE_URL=\"your-neondb-connection-string\"\n```\n\nGet your connection string from your NeonDB dashboard at [neon.tech](https://neon.tech).",
            "include": true
          },
          "option3": {
            "content": "Add your Supabase credentials:\n\n```env\nNEXT_PUBLIC_SUPABASE_URL=your-supabase-url\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key\nSUPABASE_SERVICE_ROLE_KEY=your-service-role-key\n```\n\nFind these values in your Supabase project's API settings.",
            "include": true
          },
          "option4": {
            "content": "Add your Better Auth configuration:\n\n```env\nBETTER_AUTH_SECRET=your-secret-key\nBETTER_AUTH_URL=http://localhost:3000\n```\n\nGenerate a secure secret key by running:\n\n```bash\nopenssl rand -base64 32\n```",
            "include": true
          },
          "option5": {
            "content": "Add your Stripe keys:\n\n```env\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your-publishable-key\nSTRIPE_SECRET_KEY=your-secret-key\nSTRIPE_WEBHOOK_SECRET=your-webhook-secret\n```\n\nGet these from your Stripe Dashboard at [stripe.com/dashboard](https://dashboard.stripe.com).",
            "include": true
          },
          "option6": {
            "content": "Add your PayPal credentials:\n\n```env\nNEXT_PUBLIC_PAYPAL_CLIENT_ID=your-client-id\nPAYPAL_CLIENT_SECRET=your-client-secret\n```\n\nGet these from your PayPal Developer Dashboard at [developer.paypal.com](https://developer.paypal.com).",
            "include": true
          },
          "option7": {
            "content": "Add your Resend API key:\n\n```env\nRESEND_API_KEY=your-resend-api-key\n```\n\nGet your API key from [resend.com/api-keys](https://resend.com/api-keys).",
            "include": true
          },
          "option8": {
            "content": "Add your OpenRouter API key:\n\n```env\nOPENROUTER_API_KEY=your-openrouter-api-key\n```\n\nGet your API key from [openrouter.ai/keys](https://openrouter.ai/keys).",
            "include": true
          }
        },
        "section5": {
          "option1": {
            "content": "## Development\n\n### Running the Application Locally\n\nStart the development server:\n\n```bash\nnpm run dev\n```\n\nOpen your web browser and visit [http://localhost:3000](http://localhost:3000)\n\nThe application will automatically reload when you make changes to the code.\n\n### Available Commands\n\n- `npm run dev` - Starts the development server\n- `npm run build` - Creates an optimized production build\n- `npm run start` - Runs the production build locally\n- `npm run lint` - Checks code for potential issues",
            "include": true
          },
          "option2": {
            "content": "- `npm run test` - Runs all tests\n- `npm run test:e2e` - Runs end-to-end tests with Playwright",
            "include": true
          },
          "option3": {
            "content": "- `npm run cypress:open` - Opens Cypress test runner\n- `npm run cypress:run` - Runs Cypress tests in headless mode",
            "include": true
          },
          "option4": {
            "content": "- `npx prisma studio` - Opens a visual database editor\n- `npx prisma migrate dev` - Creates and applies database migrations\n- `npx prisma generate` - Generates Prisma client types",
            "include": true
          }
        },
        "section6": {
          "option1": {
            "content": "## Deployment\n\n### Deploying to Vercel\n\nVercel is the recommended platform for deploying Next.js applications:\n\n1. **Create a Vercel account**\n\n   Visit [vercel.com](https://vercel.com) and sign up with your GitHub account.\n\n2. **Import your project**\n\n   - Click \"New Project\" in your Vercel dashboard\n   - Import your GitHub repository\n   - Vercel will automatically detect Next.js settings\n\n3. **Add environment variables**\n\n   In your project settings, add all the environment variables from your `.env.local` file.\n\n4. **Deploy**\n\n   Click \"Deploy\" and Vercel will build and publish your application.\n\nYour application will be live at `https://your-project-name.vercel.app`\n\nEvery time you push code to your main branch, Vercel will automatically deploy the updates.",
            "include": true
          },
          "option2": {
            "content": "### Deploying Your Database to Railway\n\nIf you're using NeonDB or need to host PostgreSQL:\n\n1. **Create a Railway account**\n\n   Visit [railway.app](https://railway.app) and sign up.\n\n2. **Create a new PostgreSQL database**\n\n   - Click \"New Project\"\n   - Select \"Provision PostgreSQL\"\n   - Copy the connection string from the \"Connect\" tab\n\n3. **Update your environment variables**\n\n   Add the Railway database connection string to your Vercel environment variables.\n\n4. **Run migrations**\n\n   After deployment, run your database migrations:\n\n   ```bash\n   npx prisma migrate deploy\n   ```",
            "include": true
          }
        }
      },
      "include": true
    },
    "readme.component.AppStructure": {
      "id": "component-AppStructure",
      "name": "AppStructure",
      "displayName": "AppStructure",
      "type": "component",
      "path": "readme.component.AppStructure",
      "urlPath": "",
      "componentId": "AppStructure",
      "include": true
    },
    "readme.component.SiteMap": {
      "id": "component-SiteMap",
      "name": "SiteMap",
      "displayName": "SiteMap",
      "type": "component",
      "path": "readme.component.SiteMap",
      "urlPath": "",
      "componentId": "SiteMap",
      "include": true
    },
    "robots": {
      "id": "robots",
      "name": "robots",
      "displayName": "ROBOTS",
      "type": "file",
      "order": 7,
      "path": "robots",
      "urlPath": "/robots",
      "content": "",
      "components": [],
      "sections": {},
      "include": true
    },
    "claude": {
      "id": "claude",
      "name": "claude",
      "displayName": "CLAUDE",
      "type": "file",
      "order": 8,
      "path": "claude",
      "urlPath": "/claude",
      "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Core Technologies\n\n<!-- section-1 -->\n\n# General rules:\n\n- Don't include any comments in any files.\n- All errors should be thrown - no \"fallback\" functionality\n- Import \"cn\" from \"@/lib/utils\" to concatinate classes.\n\n# File Organization and Naming Conventions\n\n<!-- section-2 -->\n\n# Hook, action, store and type patterns\n\n<!-- section-3 -->\n\n## Example of file patterns - [\\`docs/utils.md\\`](docs/utils.md)\n\nFollow the examples outlined in [\\`docs/utils.md\\`](docs/utils.md) when working on hook, action, store or type files. The file also contains the \\`prisma-rls.ts\\` and \\`action.utils.ts\\` files for reference.\n\n# Testing\n\n<!-- section-4 -->\n\n# Console.logging\n\nAll logging should be performed using the \\`conditionalLog\\` function exported from \\`lib/log.utils.ts\\`\nThe \\`NEXT_PUBLIC_LOG_LABELS\\` variable in \\`.env.local\\` stores a comma separated string of log labels. Logs are returned if \\`NEXT_PUBLIC_LOG_LABELS=\"all\"\\`, or if \\`NEXT_PUBLIC_LOG_LABELS\\` includes the label arg in \\`conditionalLog\\`.\n",
      "components": [],
      "sections": {
        "section1": {
          "option1": {
            "content": "**Next.js**: React framework providing server-side rendering, routing, and full-stack capabilities essential for modern web applications.",
            "include": true
          },
          "option2": {
            "content": "**TailwindCSS v4**: Utility-first CSS framework for rapid UI development with consistent styling across the application.",
            "include": true
          },
          "option3": {
            "content": "**Shadcn/ui**: Component library built on Radix UI and Tailwind CSS, providing accessible and customizable UI components.",
            "include": true
          },
          "option4": {
            "content": "**Zustand**: Lightweight state management solution for managing global application state with minimal boilerplate.",
            "include": true
          },
          "option5": {
            "content": "**React Query**: Data fetching and caching library that manages server state, handling loading states, errors, and data synchronization.",
            "include": true
          },
          "option6": {
            "content": "**Supabase**: Backend-as-a-service platform providing database, authentication, file storage, and real-time capabilities with built-in security and scalability.",
            "include": true
          },
          "option7": {
            "content": "**NeonDB**: Serverless PostgreSQL database hosting platform providing automatic scaling and branching capabilities.",
            "include": true
          },
          "option8": {
            "content": "**Prisma**: Type-safe database ORM providing schema management, migrations, and query building for PostgreSQL database operations.",
            "include": true
          },
          "option9": {
            "content": "**Better Auth**: Authentication library providing secure user authentication and session management with support for multiple authentication methods.",
            "include": true
          },
          "option10": {
            "content": "**PostgreSQL**: Relational database system storing application data including user accounts, authentication sessions, and application-specific data.",
            "include": true
          },
          "option11": {
            "content": "**Vercel**: Serverless deployment platform optimized for Next.js applications, providing automatic scaling and edge network distribution.",
            "include": true
          },
          "option12": {
            "content": "**Railway**: Always-on server deployment platform required for continuous monitoring and background processes.",
            "include": true
          },
          "option13": {
            "content": "**Cypress**: End-to-end testing framework for automated browser testing and quality assurance.",
            "include": true
          },
          "option14": {
            "content": "**Resend**: Email delivery service for sending authentication and notification emails with high deliverability rates.",
            "include": true
          },
          "option15": {
            "content": "**Stripe**: Payment processing platform for one-time payments and subscription billing with secure transaction handling.",
            "include": true
          },
          "option16": {
            "content": "**PayPal**: Payment processing platform for accepting PayPal payments with buyer and seller protection.",
            "include": true
          },
          "option17": {
            "content": "**OpenRouter**: AI model routing platform providing access to multiple language models for AI-powered features.",
            "include": true
          }
        },
        "section2": {
          "option1": {
            "content": "Types and store files alongside ancestor files. Actions and hooks files alongside descendent files.\n\n```txt\napp/\n├── layout.tsx\n├── layout.providers.tsx\n├── layout.types.ts\n├── layout.stores.ts ◄─── useAppStore\n└── (dashboard)/\n    ├── layout.tsx\n    ├── layout.types.tsx\n    ├── layout.stores.tsx ◄─── useDashboardStore\n    ├── page.tsx              ─┐\n    ├── page.hooks.tsx         ├────► useAppStore\n    ├── Component.tsx          ├────► useDashboardStore\n    ├── Component.hooks.tsx   ─┘\n    ├── page.actions.ts\n    └── Component.actions.ts\n\n    key:\n    ◄─── = defined\n    ───► = imported\n```",
            "include": true
          },
          "option2": {
            "content": "<!-- component-AppStructure -->",
            "include": true
          }
        },
        "section3": {
          "option1": {
            "content": "**Client-side only (No database)**\n\nComponent <-> hook <-> store\n\n- React Query hooks fetch data from external APIs or manage client-side state.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.",
            "include": true
          },
          "option2": {
            "content": "**NeonDB + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
            "include": true
          },
          "option3": {
            "content": "**Supabase + Better Auth + Prisma**\n\nDB <-> Action <-> hook <-> store\n\n- Better-auth client methods are called directly in react-query hooks.\n- Prisma client queries are called in actions via getAuthenticatedClient.\n- Actions are called via react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `\"@prisma/client\"`",
            "include": true
          },
          "option4": {
            "content": "**Supabase only (Supabase Auth)**\n\nDB <-> Supabase Client <-> hook <-> store\n\n- Supabase client queries are called directly in react-query hooks.\n- Data returned in the onSuccess function of react-query hooks is used to update the corresponding zustand store.\n- Loading and error state is managed via the react-query hooks, NOT the zustand store.\n- All db types should be defined from `@/integrations/supabase/types`.",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "All tests should be performed with Playwright and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
            "include": true
          },
          "option2": {
            "content": "All tests should be performed with Playwright or Cypress and documented in the `Tests.md` document. For complete testing instructions, patterns, and documentation format, refer to [`docs/Testing.md`](docs/Testing.md).\n\n**Test rules:**\n\n- The test should find elements in the DOM via data-attributes. Add corresponding data-attributes to the elements in the components. Import the data-attribute values from an enum exported from `@/test.types.ts`\n- Do not use wait in the tests. Only use timeouts.",
            "include": true
          }
        }
      },
      "include": true
    },
    "code-files": {
      "id": "code-files",
      "name": "code-files",
      "displayName": "Code files",
      "type": "directory",
      "path": "code-files",
      "urlPath": "/code-files",
      "include": true,
      "children": []
    },
    "docs": {
      "id": "docs",
      "name": "docs",
      "displayName": "docs",
      "type": "directory",
      "path": "docs",
      "urlPath": "/docs",
      "include": true,
      "children": [
        {
          "id": "docs.deployment-instructions",
          "name": "deployment-instructions",
          "displayName": "Deployment instructions",
          "type": "file",
          "order": 9,
          "path": "docs.deployment-instructions",
          "urlPath": "/docs/deployment-instructions",
          "content": "",
          "components": [],
          "sections": {},
          "include": true
        },
        {
          "id": "docs.util",
          "name": "util",
          "displayName": "util",
          "type": "file",
          "order": 10,
          "path": "docs.util",
          "urlPath": "/docs/util",
          "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
          "components": [],
          "sections": {
            "section1": {
              "option1": {
                "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
                "include": true
              },
              "option2": {
                "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
                "include": true
              }
            },
            "section2": {
              "option1": {
                "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
                "include": true
              }
            },
            "section3": {
              "option1": {
                "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
                "include": true
              },
              "option2": {
                "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                "include": true
              },
              "option3": {
                "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                "include": true
              },
              "option4": {
                "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
                "include": true
              }
            },
            "section4": {
              "option1": {
                "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
                "include": true
              },
              "option2": {
                "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
                "include": true
              },
              "option3": {
                "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
                "include": true
              }
            },
            "section5": {
              "option1": {
                "content": "**No utility files needed for client-side only applications.**",
                "include": true
              },
              "option2": {
                "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                "include": true
              },
              "option3": {
                "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
                "include": true
              }
            }
          },
          "include": true
        }
      ]
    },
    "docs.deployment-instructions": {
      "id": "docs.deployment-instructions",
      "name": "deployment-instructions",
      "displayName": "Deployment instructions",
      "type": "file",
      "order": 9,
      "path": "docs.deployment-instructions",
      "urlPath": "/docs/deployment-instructions",
      "content": "",
      "components": [],
      "sections": {},
      "include": true
    },
    "docs.util": {
      "id": "docs.util",
      "name": "util",
      "displayName": "util",
      "type": "file",
      "order": 10,
      "path": "docs.util",
      "urlPath": "/docs/util",
      "content": "# File examples:\n\n## Types file example:\n\n<!-- section-1 -->\n\n## Stores file example:\n\n<!-- section-2 -->\n\n## Actions file example:\n\n<!-- section-3 -->\n\n# Hooks file example\n\n<!-- section-4 -->\n\n# Utility files\n\n<!-- section-5 -->\n",
      "components": [],
      "sections": {
        "section1": {
          "option1": {
            "content": "**Types file example (Client-side):**\n\n```typescript\nexport interface AppState {\n  data: any[];\n  setData: (data: any[]) => void;\n  isLoading: boolean;\n  setIsLoading: (isLoading: boolean) => void;\n  reset: () => void;\n}\n\nexport interface ApiData {\n  id: string;\n  name: string;\n  value: number;\n}\n```",
            "include": true
          },
          "option2": {
            "content": "**Types file example (With Database):**\n\n```typescript\nimport { User } from \"@prisma/client\";\n\nexport interface AppState {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  tempEmail?: string;\n  setTempEmail: (tempEmail: string) => void;\n  reset: () => void;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n```",
            "include": true
          }
        },
        "section2": {
          "option1": {
            "content": "**Stores file example:**\n\n```typescript\nimport { UserRole } from \"@prisma/client\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { AppState, ExtendedUser, RedirectState } from \"./layout.types\";\n\nconst initialState = {\n  user: null,\n};\n\nexport const useAppStore = create<AppState>()((set) => ({\n  ...initialState,\n  setUser: (user) => set({ user, profile: user?.profile || null }),\n  reset: () => set(initialState),\n}));\n```",
            "include": true
          }
        },
        "section3": {
          "option1": {
            "content": "**No actions file needed for client-side only applications.**\n\nUse API routes or external API calls directly in hooks with React Query.",
            "include": true
          },
          "option2": {
            "content": "**Actions file example (NeonDB + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
            "include": true
          },
          "option3": {
            "content": "**Actions file example (Supabase + Better Auth):**\n\n```typescript\n\"use server\";\n\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\nimport { auth } from \"@/lib/auth\";\nimport { getAuthenticatedClient } from \"@/lib/auth.utils\";\nimport { User } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\n\nexport const getUserAction = async (): Promise<ActionResponse<User | null>> => {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) return getActionResponse();\n\n    const { db } = await getAuthenticatedClient();\n\n    const prismaUser = await db.user.findUnique({\n      where: { id: session.user.id },\n    });\n\n    return getActionResponse({ data: prismaUser });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
            "include": true
          },
          "option4": {
            "content": "**Actions file example (Supabase Auth Only):**\n\n```typescript\n\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { ActionResponse, getActionResponse } from \"@/lib/action.utils\";\n\nexport const getUserAction = async (): Promise<ActionResponse<any>> => {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n    if (authError || !user) {\n      return getActionResponse({ error: authError?.message || \"Not authenticated\" });\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', user.id)\n      .single();\n\n    if (error) throw error;\n\n    return getActionResponse({ data });\n  } catch (error) {\n    return getActionResponse({ error });\n  }\n};\n```",
            "include": true
          }
        },
        "section4": {
          "option1": {
            "content": "**Hooks file example (Client-side):**\n\n```typescript\n\"use client\";\n\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetData = () => {\n  const { setData } = useAppStore();\n\n  return useQuery({\n    queryKey: [\"data\"],\n    queryFn: async () => {\n      const response = await fetch(\"/api/data\");\n      if (!response.ok) throw new Error(\"Failed to fetch\");\n      const data = await response.json();\n      setData(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useCreateData = () => {\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (newData: any) => {\n      const response = await fetch(\"/api/data\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(newData),\n      });\n      if (!response.ok) throw new Error(\"Failed to create\");\n      return response.json();\n    },\n    onSuccess: () => {\n      router.refresh();\n    },\n  });\n};\n```",
            "include": true
          },
          "option2": {
            "content": "**Hooks file example (Better Auth):**\n\n```typescript\n\"use client\";\n\nimport { configuration, privatePaths } from \"@/configuration\";\nimport { signIn } from \"@/lib/auth-client\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { usePathname, useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { Toast } from \"../(components)/Toast\";\nimport { CypressDataAttributes } from \"../../types/cypress.types\";\nimport { useAppStore, useRedirectStore } from \"../layout.stores\";\nimport { SignInData } from \"../layout.types\";\nimport { getUserAction } from \"./layout.actions\";\nimport { useAuthLayoutStore } from \"./layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const { reset: resetAuthLayout } = useAuthLayoutStore();\n  const { setUserData } = useRedirectStore();\n  const pathname = usePathname();\n\n  const router = useRouter();\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const { data, error } = await getUserAction();\n      if (!data || error) {\n        if (privatePaths.includes(pathname)) {\n          router.push(configuration.paths.signIn);\n        }\n        reset();\n        resetAuthLayout();\n      }\n      if (error) throw error;\n      setUser(data ?? null);\n\n      setUserData(data);\n\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser, setTempEmail } = useAppStore();\n  const { setUserData } = useRedirectStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async (signInData: SignInData) => {\n      const { error } = await signIn.email({\n        email: signInData.email,\n        password: signInData.password,\n      });\n\n      if (error?.status === 403) setTempEmail(signInData.email);\n\n      if (error) throw error;\n      const { data: userData, error: userError } = await getUserAction();\n\n      if (userError) throw new Error(userError);\n\n      return userData;\n    },\n    onSuccess: (data) => {\n      if (data) {\n        setUser(data);\n        setUserData(data);\n      }\n      toast.custom(() => (\n        <Toast\n          variant=\"success\"\n          title=\"Success\"\n          message=\"Successfully signed in\"\n          data-cy={CypressDataAttributes.TOAST_SUCCESS}\n        />\n      ));\n      if (data && !data.profile?.isOnboardingComplete) {\n        router.push(configuration.paths.onboarding);\n        return;\n      }\n      router.push(configuration.paths.home);\n    },\n    onError: (\n      error: {\n        code?: string | undefined;\n        message?: string | undefined;\n        status: number;\n        statusText: string;\n      } | null\n    ) => {\n      if (error?.status === 403) return;\n      toast.custom(() => (\n        <Toast\n          variant=\"error\"\n          title=\"Sign In Failed\"\n          message={error?.message || \"Failed to sign in\"}\n          data-cy={CypressDataAttributes.TOAST_ERROR}\n        />\n      ));\n    },\n  });\n};\n```",
            "include": true
          },
          "option3": {
            "content": "**Hooks file example (Supabase Auth):**\n\n```typescript\n\"use client\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useAppStore } from \"../layout.stores\";\n\nexport const useGetUser = () => {\n  const { setUser, reset } = useAppStore();\n  const router = useRouter();\n\n  return useQuery({\n    queryKey: [\"user\"],\n    queryFn: async () => {\n      const supabase = createClient();\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n\n      if (authError || !user) {\n        reset();\n        return null;\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) throw error;\n\n      setUser(data);\n      return data;\n    },\n    staleTime: 1000 * 60 * 5,\n  });\n};\n\nexport const useSignIn = () => {\n  const { setUser } = useAppStore();\n  const router = useRouter();\n\n  return useMutation({\n    mutationFn: async ({ email, password }: { email: string; password: string }) => {\n      const supabase = createClient();\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n\n      return data.user;\n    },\n    onSuccess: (user) => {\n      setUser(user);\n      router.push('/dashboard');\n    },\n  });\n};\n```",
            "include": true
          }
        },
        "section5": {
          "option1": {
            "content": "**No utility files needed for client-side only applications.**",
            "include": true
          },
          "option2": {
            "content": "**Utility files (Better Auth + Prisma):**\n\n## `prisma-rls.ts`:\n\n```typescript\nimport { Prisma } from \"@prisma/client\";\nimport { prisma } from \"./prisma\";\n\nfunction forUser(userId: string, tenantId?: string) {\n  return Prisma.defineExtension((prisma) =>\n    prisma.$extends({\n      query: {\n        $allModels: {\n          async $allOperations({ args, query }) {\n            if (tenantId) {\n              const [, , result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            } else {\n              const [, result] = await prisma.$transaction([\n                prisma.$executeRaw`SELECT set_config('app.current_user_id', ${userId}, TRUE)`,\n                query(args),\n              ]);\n              return result;\n            }\n          },\n        },\n      },\n    })\n  );\n}\n\nexport function createRLSClient(userId: string, tenantId?: string) {\n  return prisma.$extends(forUser(userId, tenantId));\n}\n```\n\n## `auth.util.ts`\n\n```typescript\nimport { User } from \"better-auth\";\nimport jwt from \"jsonwebtoken\";\nimport { headers } from \"next/headers\";\nimport { auth, Session } from \"./auth\";\nimport { createRLSClient } from \"./prisma-rls\";\n\nexport async function getAuthenticatedClient(user?: User): Promise<{\n  db: ReturnType<typeof createRLSClient>;\n  session: Session | null;\n}> {\n  const headersList = await headers();\n\n  const session = await auth.api.getSession({\n    headers: headersList,\n  });\n\n  const userId = user?.id || session?.user.id;\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const db = createRLSClient(userId);\n\n  return { db, session };\n}\n\nexport function generateSupabaseJWT(userId: string, userRole: string): string {\n  const jwtSecret = process.env.SUPABASE_JWT_SECRET;\n\n  if (!jwtSecret) {\n    throw new Error(\"SUPABASE_JWT_SECRET is required for JWT generation\");\n  }\n\n  const payload = {\n    aud: \"authenticated\",\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    sub: userId,\n    email: `${userId}@better-auth.local`,\n    role: \"authenticated\",\n    user_metadata: {\n      better_auth_user_id: userId,\n      better_auth_role: userRole,\n    },\n    app_metadata: {\n      provider: \"better-auth\",\n      providers: [\"better-auth\"],\n    },\n  };\n\n  return jwt.sign(payload, jwtSecret, {\n    algorithm: \"HS256\",\n  });\n}\n```\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
            "include": true
          },
          "option3": {
            "content": "**Utility files (Supabase):**\n\n## `log.util.ts`:\n\n```typescript\nexport enum LOG_LABELS {\n  GENERATE = \"generate\",\n  API = \"api\",\n  AUTH = \"auth\",\n  DB = \"db\",\n  FETCH = \"fetch\",\n  RATE_LIMIT = \"rate-limit\",\n  IMAGE = \"image\",\n  WIDGET = \"widget\",\n}\n\ninterface ConditionalLogOptions {\n  maxStringLength?: number;\n  label: LOG_LABELS | string;\n}\n\nexport function conditionalLog(\n  data: unknown,\n  options: ConditionalLogOptions\n): string | null {\n  const { maxStringLength = 200, label } = options;\n\n  const logLabels = process.env.NEXT_PUBLIC_LOG_LABELS;\n\n  if (!logLabels || logLabels === \"none\") {\n    return null;\n  }\n\n  if (logLabels !== \"all\") {\n    const allowedLabels = logLabels.split(\",\").map((l) => l.trim());\n    if (!allowedLabels.includes(label)) {\n      return null;\n    }\n  }\n\n  try {\n    const processedData = deepStringify(data, maxStringLength, new WeakSet());\n    const result = JSON.stringify(processedData);\n    return result.replace(/\\\\s+/g, \"\");\n  } catch (error) {\n    return JSON.stringify({ error: \"Failed to stringify data\", label });\n  }\n}\n\nfunction deepStringify(\n  value: unknown,\n  maxLength: number,\n  seen: WeakSet<object>\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    return truncateString(value, maxLength);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: truncateString(value.message, maxLength),\n      stack: value.stack ? truncateString(value.stack, maxLength) : undefined,\n    };\n  }\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) {\n      return \"[Circular Reference]\";\n    }\n\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      const result = value.map((item) => deepStringify(item, maxLength, seen));\n      seen.delete(value);\n      return result;\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value)) {\n      result[key] = deepStringify(val, maxLength, seen);\n    }\n    seen.delete(value);\n    return result;\n  }\n\n  return String(value);\n}\n\nfunction truncateString(str: string, maxLength: number): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  const startLength = Math.floor((maxLength - 3) / 2);\n  const endLength = maxLength - 3 - startLength;\n\n  return str.slice(0, startLength) + \"...\" + str.slice(-endLength);\n}\n```",
            "include": true
          }
        }
      },
      "include": true
    },
    "start-here": {
      "id": "start-here",
      "name": "start-here",
      "displayName": "Start here",
      "type": "directory",
      "path": "start-here",
      "urlPath": "/start-here",
      "include": true,
      "children": [
        {
          "id": "start-here.tech-stack",
          "name": "tech-stack",
          "displayName": "Tech Stack",
          "type": "file",
          "order": 1,
          "path": "start-here.tech-stack",
          "urlPath": "/start-here/tech-stack",
          "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
          "components": [
            {
              "id": "component-InitialConfiguration",
              "name": "InitialConfiguration",
              "displayName": "InitialConfiguration",
              "type": "component",
              "path": "tech-stack.component.InitialConfiguration",
              "urlPath": "",
              "componentId": "InitialConfiguration",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.theme",
          "name": "theme",
          "displayName": "Theme",
          "type": "file",
          "order": 2,
          "path": "start-here.theme",
          "urlPath": "/start-here/theme",
          "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
          "components": [
            {
              "id": "component-ThemeConfiguration",
              "name": "ThemeConfiguration",
              "displayName": "ThemeConfiguration",
              "type": "component",
              "path": "theme.component.ThemeConfiguration",
              "urlPath": "",
              "componentId": "ThemeConfiguration",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.layout-routes",
          "name": "layout-routes",
          "displayName": "Layout & routes",
          "type": "file",
          "order": 3,
          "path": "start-here.layout-routes",
          "urlPath": "/start-here/layout-routes",
          "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
          "components": [
            {
              "id": "component-LayoutAndStructure",
              "name": "LayoutAndStructure",
              "displayName": "LayoutAndStructure",
              "type": "component",
              "path": "layout-routes.component.LayoutAndStructure",
              "urlPath": "",
              "componentId": "LayoutAndStructure",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.database",
          "name": "database",
          "displayName": "Database",
          "type": "file",
          "order": 4,
          "path": "start-here.database",
          "urlPath": "/start-here/database",
          "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
          "components": [
            {
              "id": "component-DatabaseConfiguration",
              "name": "DatabaseConfiguration",
              "displayName": "DatabaseConfiguration",
              "type": "component",
              "path": "database.component.DatabaseConfiguration",
              "urlPath": "",
              "componentId": "DatabaseConfiguration",
              "include": true
            }
          ],
          "sections": {},
          "include": true
        },
        {
          "id": "start-here.next-steps",
          "name": "next-steps",
          "displayName": "Next Steps",
          "type": "file",
          "order": 5,
          "path": "start-here.next-steps",
          "urlPath": "/start-here/next-steps",
          "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
          "components": [],
          "sections": {},
          "include": true
        }
      ]
    },
    "start-here.tech-stack": {
      "id": "start-here.tech-stack",
      "name": "tech-stack",
      "displayName": "Tech Stack",
      "type": "file",
      "order": 1,
      "path": "start-here.tech-stack",
      "urlPath": "/start-here/tech-stack",
      "content": "# {{appName:Your app name}} development roadmap\n\nWelcome to the development roadmap for {{appName:Your app name}}!\n\nThis collection of documents provides comprehensive instructions for creating a custom full-stack web application.\n\n## Technology stack\n\n{{appName:Your app name}} is a progressive web app built with the technologies outlined below. Start by installing these technologies using their \\`npm install\\` commands.\n\n<!-- component-InitialConfiguration -->\n",
      "components": [
        {
          "id": "component-InitialConfiguration",
          "name": "InitialConfiguration",
          "displayName": "InitialConfiguration",
          "type": "component",
          "path": "tech-stack.component.InitialConfiguration",
          "urlPath": "",
          "componentId": "InitialConfiguration",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "tech-stack.component.InitialConfiguration": {
      "id": "component-InitialConfiguration",
      "name": "InitialConfiguration",
      "displayName": "InitialConfiguration",
      "type": "component",
      "path": "tech-stack.component.InitialConfiguration",
      "urlPath": "",
      "componentId": "InitialConfiguration",
      "include": true
    },
    "start-here.theme": {
      "id": "start-here.theme",
      "name": "theme",
      "displayName": "Theme",
      "type": "file",
      "order": 2,
      "path": "start-here.theme",
      "urlPath": "/start-here/theme",
      "content": "# Theme configuration\n\nAdd the css below to your \\`styles/global.css\\` file and import the components from \\`components/ui\\` to apply your theme.\n\n<!-- component-ThemeConfiguration -->\n",
      "components": [
        {
          "id": "component-ThemeConfiguration",
          "name": "ThemeConfiguration",
          "displayName": "ThemeConfiguration",
          "type": "component",
          "path": "theme.component.ThemeConfiguration",
          "urlPath": "",
          "componentId": "ThemeConfiguration",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "theme.component.ThemeConfiguration": {
      "id": "component-ThemeConfiguration",
      "name": "ThemeConfiguration",
      "displayName": "ThemeConfiguration",
      "type": "component",
      "path": "theme.component.ThemeConfiguration",
      "urlPath": "",
      "componentId": "ThemeConfiguration",
      "include": true
    },
    "start-here.layout-routes": {
      "id": "start-here.layout-routes",
      "name": "layout-routes",
      "displayName": "Layout & routes",
      "type": "file",
      "order": 3,
      "path": "start-here.layout-routes",
      "urlPath": "/start-here/layout-routes",
      "content": "# Layout wire frame and route structure\n\nCreate page and layout files within the nested directory structure outlined below to implement your app's route and layout structure\n\n<!-- component-LayoutAndStructure -->\n",
      "components": [
        {
          "id": "component-LayoutAndStructure",
          "name": "LayoutAndStructure",
          "displayName": "LayoutAndStructure",
          "type": "component",
          "path": "layout-routes.component.LayoutAndStructure",
          "urlPath": "",
          "componentId": "LayoutAndStructure",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "layout-routes.component.LayoutAndStructure": {
      "id": "component-LayoutAndStructure",
      "name": "LayoutAndStructure",
      "displayName": "LayoutAndStructure",
      "type": "component",
      "path": "layout-routes.component.LayoutAndStructure",
      "urlPath": "",
      "componentId": "LayoutAndStructure",
      "include": true
    },
    "start-here.database": {
      "id": "start-here.database",
      "name": "database",
      "displayName": "Database",
      "type": "file",
      "order": 4,
      "path": "start-here.database",
      "urlPath": "/start-here/database",
      "content": "# Database\n\nDefine your schema, client files and Row Level Security to configure your database.\n\n<!-- component-DatabaseConfiguration -->\n",
      "components": [
        {
          "id": "component-DatabaseConfiguration",
          "name": "DatabaseConfiguration",
          "displayName": "DatabaseConfiguration",
          "type": "component",
          "path": "database.component.DatabaseConfiguration",
          "urlPath": "",
          "componentId": "DatabaseConfiguration",
          "include": true
        }
      ],
      "sections": {},
      "include": true
    },
    "database.component.DatabaseConfiguration": {
      "id": "component-DatabaseConfiguration",
      "name": "DatabaseConfiguration",
      "displayName": "DatabaseConfiguration",
      "type": "component",
      "path": "database.component.DatabaseConfiguration",
      "urlPath": "",
      "componentId": "DatabaseConfiguration",
      "include": true
    },
    "start-here.next-steps": {
      "id": "start-here.next-steps",
      "name": "next-steps",
      "displayName": "Next Steps",
      "type": "file",
      "order": 5,
      "path": "start-here.next-steps",
      "urlPath": "/start-here/next-steps",
      "content": "# Next steps\n\n1. Download your Roadmap\n2. Run \\`npx create-next-app@latest\\` to create your project repository.\n3. Paste your Roadmap into your project repository.\n4. Refer your AI to the \\`ROBOTS.md\\` file\n5. Start building!\n",
      "components": [],
      "sections": {},
      "include": true
    }
  },
  "contentVersion": 36
}